{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The main goal of this tutorial is to learn the docker basic concepts from a user perspective and to get familiar with the docker cli. You will learn about: how docker stores images and manages container data how to run your first container how to run a service in a docker container and make it available outside of Docker how to persist your data how to install and use a docker web interface Note How to create (e.g. from a Dockerfile) or modify a docker image and share it using a registry is out of the scope of this tutorial and will be covered in part 2.","title":"Home"},{"location":"container/env_vars/","text":"An environment variable consists of a variable name and its value. There are two ways to set environment variables for a docker container: with CLI arguments, using an env file. CLI arguments \u00b6 When we launch our Docker container, we can pass environment variables as key-value pairs directly into the command line using the parameter \u2013env (or its short form -e ). For instance, let's execute the following command: docker run --rm --env VARIABLE1=foobar alpine env The environment variables we set will be printed to the console: VARIABLE1=foobar As can be seen, the Docker container correctly interprets the variable VARIABLE1 . Also, we can omit the value in the command line if the variable already exists in the local environment . For example, let's define a local environment variable: export VARIABLE2=foobar2 Then, let's specify the environment variable without its value: docker run --rm --env VARIABLE2 alpine env And we can see Docker still picked up the value, this time from the surrounding environment: VARIABLE2=foobar2 Using --env-file \u00b6 The above solution is adequate when the number of variables is low. However, as soon as we have more than a handful of variables, it can quickly become cumbersome and error-prone. An alternative solution is to use a text file to store our variables , using the standard key=value format. Let's define a few variables in a file we'll call my-env.txt : $ echo VARIABLE1=foobar1 > my-env.txt $ echo VARIABLE2=foobar2 >> my-env.txt $ echo VARIABLE3=foobar3 >> my-env.txt Now, let's inject this file into our Docker container: docker run --env-file my-env.txt alpine:3 env Finally, let's take a look at the output: VARIABLE1=foobar1 VARIABLE2=foobar2 VARIABLE3=foobar3","title":"How to pass env variables to a container"},{"location":"container/env_vars/#cli-arguments","text":"When we launch our Docker container, we can pass environment variables as key-value pairs directly into the command line using the parameter \u2013env (or its short form -e ). For instance, let's execute the following command: docker run --rm --env VARIABLE1=foobar alpine env The environment variables we set will be printed to the console: VARIABLE1=foobar As can be seen, the Docker container correctly interprets the variable VARIABLE1 . Also, we can omit the value in the command line if the variable already exists in the local environment . For example, let's define a local environment variable: export VARIABLE2=foobar2 Then, let's specify the environment variable without its value: docker run --rm --env VARIABLE2 alpine env And we can see Docker still picked up the value, this time from the surrounding environment: VARIABLE2=foobar2","title":"CLI arguments"},{"location":"container/env_vars/#using-env-file","text":"The above solution is adequate when the number of variables is low. However, as soon as we have more than a handful of variables, it can quickly become cumbersome and error-prone. An alternative solution is to use a text file to store our variables , using the standard key=value format. Let's define a few variables in a file we'll call my-env.txt : $ echo VARIABLE1=foobar1 > my-env.txt $ echo VARIABLE2=foobar2 >> my-env.txt $ echo VARIABLE3=foobar3 >> my-env.txt Now, let's inject this file into our Docker container: docker run --env-file my-env.txt alpine:3 env Finally, let's take a look at the output: VARIABLE1=foobar1 VARIABLE2=foobar2 VARIABLE3=foobar3","title":"Using --env-file"},{"location":"container/example/","text":"Run a basic http server in a docker container \u00b6 Let's deploy a simple web server using nginx . First of all, let's search on Docker Hub for an already available image. We can use the search command as follows: docker search nginx You will get something like the following output: NAME DESCRIPTION STARS OFFICIAL AUTOMATED nginx Official build of Nginx. 14963 [ OK ] jwilder/nginx-proxy Automated Nginx reverse proxy for docker con\u2026 2033 [ OK ] richarvey/nginx-php-fpm Container running Nginx + PHP-FPM capable of\u2026 813 [ OK ] jc21/nginx-proxy-manager Docker container for managing Nginx proxy ho\u2026 197 linuxserver/nginx An Nginx container, brought to you by LinuxS\u2026 148 tiangolo/nginx-rtmp Docker image with Nginx using the nginx-rtmp\u2026 127 [ OK ] jlesage/nginx-proxy-manager Docker container for Nginx Proxy Manager 115 [ OK ] alfg/nginx-rtmp NGINX, nginx-rtmp-module and FFmpeg from sou\u2026 99 [ OK ] bitnami/nginx Bitnami nginx Docker Image 96 [ OK ] nginxdemos/hello NGINX webserver that serves a simple page co\u2026 70 [ OK ] privatebin/nginx-fpm-alpine PrivateBin running on an Nginx, php-fpm & Al\u2026 53 [ OK ] nginx/nginx-ingress NGINX and NGINX Plus Ingress Controllers fo\u2026 52 nginxinc/nginx-unprivileged Unprivileged NGINX Dockerfiles 36 staticfloat/nginx-certbot Opinionated setup for automatic TLS certs lo\u2026 23 [ OK ] schmunk42/nginx-redirect A very simple container to redirect HTTP tra\u2026 19 [ OK ] nginx/nginx-prometheus-exporter NGINX Prometheus Exporter for NGINX and NGIN\u2026 18 centos/nginx-112-centos7 Platform for running nginx 1 .12 or building \u2026 15 centos/nginx-18-centos7 Platform for running nginx 1 .8 or building n\u2026 13 bitwarden/nginx The Bitwarden nginx web server acting as a r\u2026 11 flashspys/nginx-static Super Lightweight Nginx Image 10 [ OK ] mailu/nginx Mailu nginx frontend 8 [ OK ] bitnami/nginx-ingress-controller Bitnami Docker Image for NGINX Ingress Contr\u2026 8 [ OK ] navidonskis/nginx-php5.6 Docker nginx + php5.6 on Ubuntu 7 [ OK ] ansibleplaybookbundle/nginx-apb An APB to deploy NGINX 2 [ OK ] wodby/nginx Generic nginx 1 [ OK ] Tip The docker search command returns the following image information: Repository names Image descriptions Stars - these measure the popularity of an image Official - an image managed by the upstream developer (e.g., the fedora image managed by the Fedora team) Automated - an image built by the Docker Hub's Automated Build process In alternative, you can make a similar search on the Docker Hub Web site : Let's download the official image using the docker image pull command: docker image pull nginx Using default tag: latest latest: Pulling from library/nginx 69692152171a: Pull complete 30afc0b18f67: Pull complete 596b1d696923: Pull complete febe5bd23e98: Pull complete 8283eee92e2f: Pull complete 351ad75a6cfa: Pull complete Digest: sha256:6d75c99af15565a301e48297fa2d121e15d80ad526f8369c526324f0f7ccb750 Status: Downloaded newer image for nginx:latest docker.io/library/nginx:latest In order to list the images downloaded on your host, you can use the command: docker image ls The output of this command provides useful information, including the size of the image: REPOSITORY TAG IMAGE ID CREATED SIZE nginx latest d1a364dc548d 10 days ago 133MB ubuntu latest 7e0aa2d69a15 5 weeks ago 72 .7MB Let's have a look at the image with the commands we have already seen in the previous section: docker image inspect nginx 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 [ { \"Id\" : \"sha256:d1a364dc548d5357f0da3268c888e1971bbdb957ee3f028fe7194f1d61c6fdee\" , \"RepoTags\" : [ \"nginx:latest\" ] , \"RepoDigests\" : [ \"nginx@sha256:6d75c99af15565a301e48297fa2d121e15d80ad526f8369c526324f0f7ccb750\" ] , \"Parent\" : \"\" , \"Comment\" : \"\" , \"Created\" : \"2021-05-25T15:43:43.382480482Z\" , \"Container\" : \"7b06b818c018bb8563a3d786d6b16971c6f470c3d4c5288d908a3851b8261086\" , \"ContainerConfig\" : { \"Hostname\" : \"7b06b818c018\" , \"Domainname\" : \"\" , \"User\" : \"\" , \"AttachStdin\" : false, \"AttachStdout\" : false, \"AttachStderr\" : false, \"ExposedPorts\" : { \"80/tcp\" : {} } , \"Tty\" : false, \"OpenStdin\" : false, \"StdinOnce\" : false, \"Env\" : [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" , \"NGINX_VERSION=1.21.0\" , \"NJS_VERSION=0.5.3\" , \"PKG_RELEASE=1~buster\" ] , \"Cmd\" : [ \"/bin/sh\" , \"-c\" , \"#(nop) \" , \"CMD [\\\"nginx\\\" \\\"-g\\\" \\\"daemon off;\\\"]\" ] , \"Image\" : \"sha256:697718de459ceac2204a10028cb4008e64513e26697c154309ae93d2f64baa57\" , \"Volumes\" : null, \"WorkingDir\" : \"\" , \"Entrypoint\" : [ \"/docker-entrypoint.sh\" ] , \"OnBuild\" : null, \"Labels\" : { \"maintainer\" : \"NGINX Docker Maintainers <docker-maint@nginx.com>\" } , \"StopSignal\" : \"SIGQUIT\" } , \"DockerVersion\" : \"19.03.12\" , \"Author\" : \"\" , \"Config\" : { \"Hostname\" : \"\" , \"Domainname\" : \"\" , \"User\" : \"\" , \"AttachStdin\" : false, \"AttachStdout\" : false, \"AttachStderr\" : false, \"ExposedPorts\" : { \"80/tcp\" : {} } , \"Tty\" : false, \"OpenStdin\" : false, \"StdinOnce\" : false, \"Env\" : [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" , \"NGINX_VERSION=1.21.0\" , \"NJS_VERSION=0.5.3\" , \"PKG_RELEASE=1~buster\" ] , \"Cmd\" : [ \"nginx\" , \"-g\" , \"daemon off;\" ] , \"Image\" : \"sha256:697718de459ceac2204a10028cb4008e64513e26697c154309ae93d2f64baa57\" , \"Volumes\" : null, \"WorkingDir\" : \"\" , \"Entrypoint\" : [ \"/docker-entrypoint.sh\" ] , \"OnBuild\" : null, \"Labels\" : { \"maintainer\" : \"NGINX Docker Maintainers <docker-maint@nginx.com>\" } , \"StopSignal\" : \"SIGQUIT\" } , \"Architecture\" : \"amd64\" , \"Os\" : \"linux\" , \"Size\" : 133117876 , \"VirtualSize\" : 133117876 , \"GraphDriver\" : { \"Data\" : { \"LowerDir\" : \"/var/lib/docker/overlay2/fa16037866db03e19d99c1d3695d6951569e751ba938036bcc1e82e31dad41cb/diff:/var/lib/docker/overlay2/adf9f3208ebac0a1566f031e9404f218349446153d3124c46c96d0db7d1b6097/diff:/var/lib/docker/overlay2/a5121e4e639c611e78ca69f1f5d90d032249852a6927b12968ac7709945f41e4/diff:/var/lib/docker/overlay2/8bf60f425fa90fe22dd757fc45d388c568254b79ec6f5bf724ac6a3a7972af84/diff:/var/lib/docker/overlay2/d75a9d8d1cabc06f29c2d1ea6854083e8de20bec99df58efed06bcbc01a9e0f4/diff\" , \"MergedDir\" : \"/var/lib/docker/overlay2/c1e6aceded10a0b1ebf0c89ed6b382faea13f6a2564b6be59641c91be4da68b3/merged\" , \"UpperDir\" : \"/var/lib/docker/overlay2/c1e6aceded10a0b1ebf0c89ed6b382faea13f6a2564b6be59641c91be4da68b3/diff\" , \"WorkDir\" : \"/var/lib/docker/overlay2/c1e6aceded10a0b1ebf0c89ed6b382faea13f6a2564b6be59641c91be4da68b3/work\" } , \"Name\" : \"overlay2\" } , \"RootFS\" : { \"Type\" : \"layers\" , \"Layers\" : [ \"sha256:02c055ef67f5904019f43a41ea5f099996d8e7633749b6e606c400526b2c4b33\" , \"sha256:766fe2c3fc083fdb0e132c138118bc931e3cd1bf4a8bdf0e049afbf64bae5ee6\" , \"sha256:83634f76e73296b28a0e90c640494970bdfc437749598e0e91e77eea9bdb6a4e\" , \"sha256:134e19b2fac580eff84faabfd5067977b79e36c5981d51fd63e8ac752dbdf9ec\" , \"sha256:5c865c78bc96874203b5aa48f1a089d1eabcbe1607edaa16aaa6dee27c985395\" , \"sha256:075508cf8f04705d8dc648cfb9f044f5dff57c31ccf34bde32cd2874f402dfad\" ] } , \"Metadata\" : { \"LastTagTime\" : \"0001-01-01T00:00:00Z\" } } ] We can see that the nginx version in our container will be 1.21.0 , the service will be listening on port 80 and the command that will be executed at the container start is nginx -g daemon off; . This is a useful exercise, but in general you will find these information in the description of the image on Docker hub. Creating a daemonized container \u00b6 In addition to the interactive containers, we can create longer-running containers. Daemonized containers don't have the interactive session we've used in our previous example and are ideal for running applications and services. Most of the containers you're likely to run will probably be daemonized. Let's start a daemonized container now. docker container run -d --name nginx nginx Note The -d flag tells Docker to detach the container to the background. The --name option allows to set a name for your container Instead of being attached to a shell, the docker run command has instead returned a container ID and returned us to our command prompt. We can see our container running with: docker container ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2f03f1f2cd10 nginx \"/docker-entrypoint.\u2026\" 13 seconds ago Up 11 seconds 80 /tcp nginx Getting the container log \u00b6 What's happening inside our container? We can use the docker container logs command to fetch the log of a container: docker container logs nginx /docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration /docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/ /docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh 10 -listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf 10 -listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf /docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh /docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh /docker-entrypoint.sh: Configuration complete ; ready for start up 2021 /06/06 14 :52:38 [ notice ] 1 #1: using the \"epoll\" event method 2021 /06/06 14 :52:38 [ notice ] 1 #1: nginx/1.21.0 2021 /06/06 14 :52:38 [ notice ] 1 #1: built by gcc 8.3.0 (Debian 8.3.0-6) 2021 /06/06 14 :52:38 [ notice ] 1 #1: OS: Linux 5.4.0-60-generic 2021 /06/06 14 :52:38 [ notice ] 1 #1: getrlimit(RLIMIT_NOFILE): 1048576:1048576 2021 /06/06 14 :52:38 [ notice ] 1 #1: start worker processes 2021 /06/06 14 :52:38 [ notice ] 1 #1: start worker process 32 2021 /06/06 14 :52:38 [ notice ] 1 #1: start worker process 33 Tip We can also monitor the container's logs much like the tail -f binary operates using the -f flag. You can also tail a portion of the logs of a container by using the --tail option. Moreover you can also use the -t flag to prefix the log entries with timestamps. Inspecting the container processes \u00b6 We can inspect the processes running inside our container using the docker container top command: UID PID PPID C STIME TTY TIME CMD root 138792 138771 0 14 :52 ? 00 :00:00 nginx: master process nginx -g daemon off ; systemd+ 138861 138792 0 14 :52 ? 00 :00:00 nginx: worker process systemd+ 138862 138792 0 14 :52 ? 00 :00:00 nginx: worker process Finding out more about our container \u00b6 Let's use again the command docker container inspect to get more information about our container: command Output docker container inspect nginx [ { \"Id\" : \"2f03f1f2cd100ec584349124a93f180fa743d1c3ab7bcc31c9d8156225d6f06a\" , \"Created\" : \"2021-06-06T14:52:36.827435939Z\" , \"Path\" : \"/docker-entrypoint.sh\" , \"Args\" : [ \"nginx\" , \"-g\" , \"daemon off;\" ] , \"State\" : { \"Status\" : \"running\" , \"Running\" : true, \"Paused\" : false, \"Restarting\" : false, \"OOMKilled\" : false, \"Dead\" : false, \"Pid\" : 138792 , \"ExitCode\" : 0 , \"Error\" : \"\" , \"StartedAt\" : \"2021-06-06T14:52:38.171320981Z\" , \"FinishedAt\" : \"0001-01-01T00:00:00Z\" } , \"Image\" : \"sha256:d1a364dc548d5357f0da3268c888e1971bbdb957ee3f028fe7194f1d61c6fdee\" , \"ResolvConfPath\" : \"/var/lib/docker/containers/2f03f1f2cd100ec584349124a93f180fa743d1c3ab7bcc31c9d8156225d6f06a/resolv.conf\" , \"HostnamePath\" : \"/var/lib/docker/containers/2f03f1f2cd100ec584349124a93f180fa743d1c3ab7bcc31c9d8156225d6f06a/hostname\" , \"HostsPath\" : \"/var/lib/docker/containers/2f03f1f2cd100ec584349124a93f180fa743d1c3ab7bcc31c9d8156225d6f06a/hosts\" , \"LogPath\" : \"/var/lib/docker/containers/2f03f1f2cd100ec584349124a93f180fa743d1c3ab7bcc31c9d8156225d6f06a/2f03f1f2cd100ec584349124a93f180fa743d1c3ab7bcc31c9d8156225d6f06a-json.log\" , \"Name\" : \"/nginx\" , \"RestartCount\" : 0 , \"Driver\" : \"overlay2\" , \"Platform\" : \"linux\" , \"MountLabel\" : \"\" , \"ProcessLabel\" : \"\" , \"AppArmorProfile\" : \"docker-default\" , \"ExecIDs\" : null, \"HostConfig\" : { \"Binds\" : null, \"ContainerIDFile\" : \"\" , \"LogConfig\" : { \"Type\" : \"json-file\" , \"Config\" : { \"max-file\" : \"3\" , \"max-size\" : \"100m\" } } , \"NetworkMode\" : \"default\" , \"PortBindings\" : {} , \"RestartPolicy\" : { \"Name\" : \"no\" , \"MaximumRetryCount\" : 0 } , \"AutoRemove\" : false, \"VolumeDriver\" : \"\" , \"VolumesFrom\" : null, \"CapAdd\" : null, \"CapDrop\" : null, \"CgroupnsMode\" : \"host\" , \"Dns\" : [] , \"DnsOptions\" : [] , \"DnsSearch\" : [] , \"ExtraHosts\" : null, \"GroupAdd\" : null, \"IpcMode\" : \"private\" , \"Cgroup\" : \"\" , \"Links\" : null, \"OomScoreAdj\" : 0 , \"PidMode\" : \"\" , \"Privileged\" : false, \"PublishAllPorts\" : false, \"ReadonlyRootfs\" : false, \"SecurityOpt\" : null, \"UTSMode\" : \"\" , \"UsernsMode\" : \"\" , \"ShmSize\" : 67108864 , \"Runtime\" : \"runc\" , \"ConsoleSize\" : [ 0 , 0 ] , \"Isolation\" : \"\" , \"CpuShares\" : 0 , \"Memory\" : 0 , \"NanoCpus\" : 0 , \"CgroupParent\" : \"\" , \"BlkioWeight\" : 0 , \"BlkioWeightDevice\" : [] , \"BlkioDeviceReadBps\" : null, \"BlkioDeviceWriteBps\" : null, \"BlkioDeviceReadIOps\" : null, \"BlkioDeviceWriteIOps\" : null, \"CpuPeriod\" : 0 , \"CpuQuota\" : 0 , \"CpuRealtimePeriod\" : 0 , \"CpuRealtimeRuntime\" : 0 , \"CpusetCpus\" : \"\" , \"CpusetMems\" : \"\" , \"Devices\" : [] , \"DeviceCgroupRules\" : null, \"DeviceRequests\" : null, \"KernelMemory\" : 0 , \"KernelMemoryTCP\" : 0 , \"MemoryReservation\" : 0 , \"MemorySwap\" : 0 , \"MemorySwappiness\" : null, \"OomKillDisable\" : false, \"PidsLimit\" : null, \"Ulimits\" : null, \"CpuCount\" : 0 , \"CpuPercent\" : 0 , \"IOMaximumIOps\" : 0 , \"IOMaximumBandwidth\" : 0 , \"MaskedPaths\" : [ \"/proc/asound\" , \"/proc/acpi\" , \"/proc/kcore\" , \"/proc/keys\" , \"/proc/latency_stats\" , \"/proc/timer_list\" , \"/proc/timer_stats\" , \"/proc/sched_debug\" , \"/proc/scsi\" , \"/sys/firmware\" ] , \"ReadonlyPaths\" : [ \"/proc/bus\" , \"/proc/fs\" , \"/proc/irq\" , \"/proc/sys\" , \"/proc/sysrq-trigger\" ] } , \"GraphDriver\" : { \"Data\" : { \"LowerDir\" : \"/var/lib/docker/overlay2/8b4c0276493d49acf7c85ad47ca5192896e9ea1ea2d2aa3f02d4f2d8eb47f58d-init/diff:/var/lib/docker/overlay2/c1e6aceded10a0b1ebf0c89ed6b382faea13f6a2564b6be59641c91be4da68b3/diff:/var/lib/docker/overlay2/fa16037866db03e19d99c1d3695d6951569e751ba938036bcc1e82e31dad41cb/diff:/var/lib/docker/overlay2/adf9f3208ebac0a1566f031e9404f218349446153d3124c46c96d0db7d1b6097/diff:/var/lib/docker/overlay2/a5121e4e639c611e78ca69f1f5d90d032249852a6927b12968ac7709945f41e4/diff:/var/lib/docker/overlay2/8bf60f425fa90fe22dd757fc45d388c568254b79ec6f5bf724ac6a3a7972af84/diff:/var/lib/docker/overlay2/d75a9d8d1cabc06f29c2d1ea6854083e8de20bec99df58efed06bcbc01a9e0f4/diff\" , \"MergedDir\" : \"/var/lib/docker/overlay2/8b4c0276493d49acf7c85ad47ca5192896e9ea1ea2d2aa3f02d4f2d8eb47f58d/merged\" , \"UpperDir\" : \"/var/lib/docker/overlay2/8b4c0276493d49acf7c85ad47ca5192896e9ea1ea2d2aa3f02d4f2d8eb47f58d/diff\" , \"WorkDir\" : \"/var/lib/docker/overlay2/8b4c0276493d49acf7c85ad47ca5192896e9ea1ea2d2aa3f02d4f2d8eb47f58d/work\" } , \"Name\" : \"overlay2\" } , \"Mounts\" : [] , \"Config\" : { \"Hostname\" : \"2f03f1f2cd10\" , \"Domainname\" : \"\" , \"User\" : \"\" , \"AttachStdin\" : false, \"AttachStdout\" : false, \"AttachStderr\" : false, \"ExposedPorts\" : { \"80/tcp\" : {} } , \"Tty\" : false, \"OpenStdin\" : false, \"StdinOnce\" : false, \"Env\" : [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" , \"NGINX_VERSION=1.21.0\" , \"NJS_VERSION=0.5.3\" , \"PKG_RELEASE=1~buster\" ] , \"Cmd\" : [ \"nginx\" , \"-g\" , \"daemon off;\" ] , \"Image\" : \"nginx\" , \"Volumes\" : null, \"WorkingDir\" : \"\" , \"Entrypoint\" : [ \"/docker-entrypoint.sh\" ] , \"OnBuild\" : null, \"Labels\" : { \"maintainer\" : \"NGINX Docker Maintainers <docker-maint@nginx.com>\" } , \"StopSignal\" : \"SIGQUIT\" } , \"NetworkSettings\" : { \"Bridge\" : \"\" , \"SandboxID\" : \"a74ea121ebf1163153ed7f24fb22b4cc11af77f336cfdbee9252d7c80ed9be0f\" , \"HairpinMode\" : false, \"LinkLocalIPv6Address\" : \"\" , \"LinkLocalIPv6PrefixLen\" : 0 , \"Ports\" : { \"80/tcp\" : null } , \"SandboxKey\" : \"/var/run/docker/netns/a74ea121ebf1\" , \"SecondaryIPAddresses\" : null, \"SecondaryIPv6Addresses\" : null, \"EndpointID\" : \"c3b64e072f7851e3bf55ba3685fa1fbdec6b9c59d18ae27e5e90a1be5728f54c\" , \"Gateway\" : \"172.17.0.1\" , \"GlobalIPv6Address\" : \"\" , \"GlobalIPv6PrefixLen\" : 0 , \"IPAddress\" : \"172.17.0.2\" , \"IPPrefixLen\" : 16 , \"IPv6Gateway\" : \"\" , \"MacAddress\" : \"02:42:ac:11:00:02\" , \"Networks\" : { \"bridge\" : { \"IPAMConfig\" : null, \"Links\" : null, \"Aliases\" : null, \"NetworkID\" : \"0aa786b7de5fbfcd3e18db78511ed544d450bb0ad198cab0244bc8b83d30b514\" , \"EndpointID\" : \"c3b64e072f7851e3bf55ba3685fa1fbdec6b9c59d18ae27e5e90a1be5728f54c\" , \"Gateway\" : \"172.17.0.1\" , \"IPAddress\" : \"172.17.0.2\" , \"IPPrefixLen\" : 16 , \"IPv6Gateway\" : \"\" , \"GlobalIPv6Address\" : \"\" , \"GlobalIPv6PrefixLen\" : 0 , \"MacAddress\" : \"02:42:ac:11:00:02\" , \"DriverOpts\" : null } } } } ] We can also selectively query the inspect results hash using the -f or --format flag. For example, let's retrieve the container network address: docker container inspect -f '{{.NetworkSettings.IPAddress}}' nginx 172.17.0.2","title":"Run a dockerized service"},{"location":"container/example/#run-a-basic-http-server-in-a-docker-container","text":"Let's deploy a simple web server using nginx . First of all, let's search on Docker Hub for an already available image. We can use the search command as follows: docker search nginx You will get something like the following output: NAME DESCRIPTION STARS OFFICIAL AUTOMATED nginx Official build of Nginx. 14963 [ OK ] jwilder/nginx-proxy Automated Nginx reverse proxy for docker con\u2026 2033 [ OK ] richarvey/nginx-php-fpm Container running Nginx + PHP-FPM capable of\u2026 813 [ OK ] jc21/nginx-proxy-manager Docker container for managing Nginx proxy ho\u2026 197 linuxserver/nginx An Nginx container, brought to you by LinuxS\u2026 148 tiangolo/nginx-rtmp Docker image with Nginx using the nginx-rtmp\u2026 127 [ OK ] jlesage/nginx-proxy-manager Docker container for Nginx Proxy Manager 115 [ OK ] alfg/nginx-rtmp NGINX, nginx-rtmp-module and FFmpeg from sou\u2026 99 [ OK ] bitnami/nginx Bitnami nginx Docker Image 96 [ OK ] nginxdemos/hello NGINX webserver that serves a simple page co\u2026 70 [ OK ] privatebin/nginx-fpm-alpine PrivateBin running on an Nginx, php-fpm & Al\u2026 53 [ OK ] nginx/nginx-ingress NGINX and NGINX Plus Ingress Controllers fo\u2026 52 nginxinc/nginx-unprivileged Unprivileged NGINX Dockerfiles 36 staticfloat/nginx-certbot Opinionated setup for automatic TLS certs lo\u2026 23 [ OK ] schmunk42/nginx-redirect A very simple container to redirect HTTP tra\u2026 19 [ OK ] nginx/nginx-prometheus-exporter NGINX Prometheus Exporter for NGINX and NGIN\u2026 18 centos/nginx-112-centos7 Platform for running nginx 1 .12 or building \u2026 15 centos/nginx-18-centos7 Platform for running nginx 1 .8 or building n\u2026 13 bitwarden/nginx The Bitwarden nginx web server acting as a r\u2026 11 flashspys/nginx-static Super Lightweight Nginx Image 10 [ OK ] mailu/nginx Mailu nginx frontend 8 [ OK ] bitnami/nginx-ingress-controller Bitnami Docker Image for NGINX Ingress Contr\u2026 8 [ OK ] navidonskis/nginx-php5.6 Docker nginx + php5.6 on Ubuntu 7 [ OK ] ansibleplaybookbundle/nginx-apb An APB to deploy NGINX 2 [ OK ] wodby/nginx Generic nginx 1 [ OK ] Tip The docker search command returns the following image information: Repository names Image descriptions Stars - these measure the popularity of an image Official - an image managed by the upstream developer (e.g., the fedora image managed by the Fedora team) Automated - an image built by the Docker Hub's Automated Build process In alternative, you can make a similar search on the Docker Hub Web site : Let's download the official image using the docker image pull command: docker image pull nginx Using default tag: latest latest: Pulling from library/nginx 69692152171a: Pull complete 30afc0b18f67: Pull complete 596b1d696923: Pull complete febe5bd23e98: Pull complete 8283eee92e2f: Pull complete 351ad75a6cfa: Pull complete Digest: sha256:6d75c99af15565a301e48297fa2d121e15d80ad526f8369c526324f0f7ccb750 Status: Downloaded newer image for nginx:latest docker.io/library/nginx:latest In order to list the images downloaded on your host, you can use the command: docker image ls The output of this command provides useful information, including the size of the image: REPOSITORY TAG IMAGE ID CREATED SIZE nginx latest d1a364dc548d 10 days ago 133MB ubuntu latest 7e0aa2d69a15 5 weeks ago 72 .7MB Let's have a look at the image with the commands we have already seen in the previous section: docker image inspect nginx 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 [ { \"Id\" : \"sha256:d1a364dc548d5357f0da3268c888e1971bbdb957ee3f028fe7194f1d61c6fdee\" , \"RepoTags\" : [ \"nginx:latest\" ] , \"RepoDigests\" : [ \"nginx@sha256:6d75c99af15565a301e48297fa2d121e15d80ad526f8369c526324f0f7ccb750\" ] , \"Parent\" : \"\" , \"Comment\" : \"\" , \"Created\" : \"2021-05-25T15:43:43.382480482Z\" , \"Container\" : \"7b06b818c018bb8563a3d786d6b16971c6f470c3d4c5288d908a3851b8261086\" , \"ContainerConfig\" : { \"Hostname\" : \"7b06b818c018\" , \"Domainname\" : \"\" , \"User\" : \"\" , \"AttachStdin\" : false, \"AttachStdout\" : false, \"AttachStderr\" : false, \"ExposedPorts\" : { \"80/tcp\" : {} } , \"Tty\" : false, \"OpenStdin\" : false, \"StdinOnce\" : false, \"Env\" : [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" , \"NGINX_VERSION=1.21.0\" , \"NJS_VERSION=0.5.3\" , \"PKG_RELEASE=1~buster\" ] , \"Cmd\" : [ \"/bin/sh\" , \"-c\" , \"#(nop) \" , \"CMD [\\\"nginx\\\" \\\"-g\\\" \\\"daemon off;\\\"]\" ] , \"Image\" : \"sha256:697718de459ceac2204a10028cb4008e64513e26697c154309ae93d2f64baa57\" , \"Volumes\" : null, \"WorkingDir\" : \"\" , \"Entrypoint\" : [ \"/docker-entrypoint.sh\" ] , \"OnBuild\" : null, \"Labels\" : { \"maintainer\" : \"NGINX Docker Maintainers <docker-maint@nginx.com>\" } , \"StopSignal\" : \"SIGQUIT\" } , \"DockerVersion\" : \"19.03.12\" , \"Author\" : \"\" , \"Config\" : { \"Hostname\" : \"\" , \"Domainname\" : \"\" , \"User\" : \"\" , \"AttachStdin\" : false, \"AttachStdout\" : false, \"AttachStderr\" : false, \"ExposedPorts\" : { \"80/tcp\" : {} } , \"Tty\" : false, \"OpenStdin\" : false, \"StdinOnce\" : false, \"Env\" : [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" , \"NGINX_VERSION=1.21.0\" , \"NJS_VERSION=0.5.3\" , \"PKG_RELEASE=1~buster\" ] , \"Cmd\" : [ \"nginx\" , \"-g\" , \"daemon off;\" ] , \"Image\" : \"sha256:697718de459ceac2204a10028cb4008e64513e26697c154309ae93d2f64baa57\" , \"Volumes\" : null, \"WorkingDir\" : \"\" , \"Entrypoint\" : [ \"/docker-entrypoint.sh\" ] , \"OnBuild\" : null, \"Labels\" : { \"maintainer\" : \"NGINX Docker Maintainers <docker-maint@nginx.com>\" } , \"StopSignal\" : \"SIGQUIT\" } , \"Architecture\" : \"amd64\" , \"Os\" : \"linux\" , \"Size\" : 133117876 , \"VirtualSize\" : 133117876 , \"GraphDriver\" : { \"Data\" : { \"LowerDir\" : \"/var/lib/docker/overlay2/fa16037866db03e19d99c1d3695d6951569e751ba938036bcc1e82e31dad41cb/diff:/var/lib/docker/overlay2/adf9f3208ebac0a1566f031e9404f218349446153d3124c46c96d0db7d1b6097/diff:/var/lib/docker/overlay2/a5121e4e639c611e78ca69f1f5d90d032249852a6927b12968ac7709945f41e4/diff:/var/lib/docker/overlay2/8bf60f425fa90fe22dd757fc45d388c568254b79ec6f5bf724ac6a3a7972af84/diff:/var/lib/docker/overlay2/d75a9d8d1cabc06f29c2d1ea6854083e8de20bec99df58efed06bcbc01a9e0f4/diff\" , \"MergedDir\" : \"/var/lib/docker/overlay2/c1e6aceded10a0b1ebf0c89ed6b382faea13f6a2564b6be59641c91be4da68b3/merged\" , \"UpperDir\" : \"/var/lib/docker/overlay2/c1e6aceded10a0b1ebf0c89ed6b382faea13f6a2564b6be59641c91be4da68b3/diff\" , \"WorkDir\" : \"/var/lib/docker/overlay2/c1e6aceded10a0b1ebf0c89ed6b382faea13f6a2564b6be59641c91be4da68b3/work\" } , \"Name\" : \"overlay2\" } , \"RootFS\" : { \"Type\" : \"layers\" , \"Layers\" : [ \"sha256:02c055ef67f5904019f43a41ea5f099996d8e7633749b6e606c400526b2c4b33\" , \"sha256:766fe2c3fc083fdb0e132c138118bc931e3cd1bf4a8bdf0e049afbf64bae5ee6\" , \"sha256:83634f76e73296b28a0e90c640494970bdfc437749598e0e91e77eea9bdb6a4e\" , \"sha256:134e19b2fac580eff84faabfd5067977b79e36c5981d51fd63e8ac752dbdf9ec\" , \"sha256:5c865c78bc96874203b5aa48f1a089d1eabcbe1607edaa16aaa6dee27c985395\" , \"sha256:075508cf8f04705d8dc648cfb9f044f5dff57c31ccf34bde32cd2874f402dfad\" ] } , \"Metadata\" : { \"LastTagTime\" : \"0001-01-01T00:00:00Z\" } } ] We can see that the nginx version in our container will be 1.21.0 , the service will be listening on port 80 and the command that will be executed at the container start is nginx -g daemon off; . This is a useful exercise, but in general you will find these information in the description of the image on Docker hub.","title":"Run a basic http server in a docker container"},{"location":"container/example/#creating-a-daemonized-container","text":"In addition to the interactive containers, we can create longer-running containers. Daemonized containers don't have the interactive session we've used in our previous example and are ideal for running applications and services. Most of the containers you're likely to run will probably be daemonized. Let's start a daemonized container now. docker container run -d --name nginx nginx Note The -d flag tells Docker to detach the container to the background. The --name option allows to set a name for your container Instead of being attached to a shell, the docker run command has instead returned a container ID and returned us to our command prompt. We can see our container running with: docker container ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2f03f1f2cd10 nginx \"/docker-entrypoint.\u2026\" 13 seconds ago Up 11 seconds 80 /tcp nginx","title":"Creating a daemonized container"},{"location":"container/example/#getting-the-container-log","text":"What's happening inside our container? We can use the docker container logs command to fetch the log of a container: docker container logs nginx /docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration /docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/ /docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh 10 -listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf 10 -listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf /docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh /docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh /docker-entrypoint.sh: Configuration complete ; ready for start up 2021 /06/06 14 :52:38 [ notice ] 1 #1: using the \"epoll\" event method 2021 /06/06 14 :52:38 [ notice ] 1 #1: nginx/1.21.0 2021 /06/06 14 :52:38 [ notice ] 1 #1: built by gcc 8.3.0 (Debian 8.3.0-6) 2021 /06/06 14 :52:38 [ notice ] 1 #1: OS: Linux 5.4.0-60-generic 2021 /06/06 14 :52:38 [ notice ] 1 #1: getrlimit(RLIMIT_NOFILE): 1048576:1048576 2021 /06/06 14 :52:38 [ notice ] 1 #1: start worker processes 2021 /06/06 14 :52:38 [ notice ] 1 #1: start worker process 32 2021 /06/06 14 :52:38 [ notice ] 1 #1: start worker process 33 Tip We can also monitor the container's logs much like the tail -f binary operates using the -f flag. You can also tail a portion of the logs of a container by using the --tail option. Moreover you can also use the -t flag to prefix the log entries with timestamps.","title":"Getting the container log"},{"location":"container/example/#inspecting-the-container-processes","text":"We can inspect the processes running inside our container using the docker container top command: UID PID PPID C STIME TTY TIME CMD root 138792 138771 0 14 :52 ? 00 :00:00 nginx: master process nginx -g daemon off ; systemd+ 138861 138792 0 14 :52 ? 00 :00:00 nginx: worker process systemd+ 138862 138792 0 14 :52 ? 00 :00:00 nginx: worker process","title":"Inspecting the container processes"},{"location":"container/example/#finding-out-more-about-our-container","text":"Let's use again the command docker container inspect to get more information about our container: command Output docker container inspect nginx [ { \"Id\" : \"2f03f1f2cd100ec584349124a93f180fa743d1c3ab7bcc31c9d8156225d6f06a\" , \"Created\" : \"2021-06-06T14:52:36.827435939Z\" , \"Path\" : \"/docker-entrypoint.sh\" , \"Args\" : [ \"nginx\" , \"-g\" , \"daemon off;\" ] , \"State\" : { \"Status\" : \"running\" , \"Running\" : true, \"Paused\" : false, \"Restarting\" : false, \"OOMKilled\" : false, \"Dead\" : false, \"Pid\" : 138792 , \"ExitCode\" : 0 , \"Error\" : \"\" , \"StartedAt\" : \"2021-06-06T14:52:38.171320981Z\" , \"FinishedAt\" : \"0001-01-01T00:00:00Z\" } , \"Image\" : \"sha256:d1a364dc548d5357f0da3268c888e1971bbdb957ee3f028fe7194f1d61c6fdee\" , \"ResolvConfPath\" : \"/var/lib/docker/containers/2f03f1f2cd100ec584349124a93f180fa743d1c3ab7bcc31c9d8156225d6f06a/resolv.conf\" , \"HostnamePath\" : \"/var/lib/docker/containers/2f03f1f2cd100ec584349124a93f180fa743d1c3ab7bcc31c9d8156225d6f06a/hostname\" , \"HostsPath\" : \"/var/lib/docker/containers/2f03f1f2cd100ec584349124a93f180fa743d1c3ab7bcc31c9d8156225d6f06a/hosts\" , \"LogPath\" : \"/var/lib/docker/containers/2f03f1f2cd100ec584349124a93f180fa743d1c3ab7bcc31c9d8156225d6f06a/2f03f1f2cd100ec584349124a93f180fa743d1c3ab7bcc31c9d8156225d6f06a-json.log\" , \"Name\" : \"/nginx\" , \"RestartCount\" : 0 , \"Driver\" : \"overlay2\" , \"Platform\" : \"linux\" , \"MountLabel\" : \"\" , \"ProcessLabel\" : \"\" , \"AppArmorProfile\" : \"docker-default\" , \"ExecIDs\" : null, \"HostConfig\" : { \"Binds\" : null, \"ContainerIDFile\" : \"\" , \"LogConfig\" : { \"Type\" : \"json-file\" , \"Config\" : { \"max-file\" : \"3\" , \"max-size\" : \"100m\" } } , \"NetworkMode\" : \"default\" , \"PortBindings\" : {} , \"RestartPolicy\" : { \"Name\" : \"no\" , \"MaximumRetryCount\" : 0 } , \"AutoRemove\" : false, \"VolumeDriver\" : \"\" , \"VolumesFrom\" : null, \"CapAdd\" : null, \"CapDrop\" : null, \"CgroupnsMode\" : \"host\" , \"Dns\" : [] , \"DnsOptions\" : [] , \"DnsSearch\" : [] , \"ExtraHosts\" : null, \"GroupAdd\" : null, \"IpcMode\" : \"private\" , \"Cgroup\" : \"\" , \"Links\" : null, \"OomScoreAdj\" : 0 , \"PidMode\" : \"\" , \"Privileged\" : false, \"PublishAllPorts\" : false, \"ReadonlyRootfs\" : false, \"SecurityOpt\" : null, \"UTSMode\" : \"\" , \"UsernsMode\" : \"\" , \"ShmSize\" : 67108864 , \"Runtime\" : \"runc\" , \"ConsoleSize\" : [ 0 , 0 ] , \"Isolation\" : \"\" , \"CpuShares\" : 0 , \"Memory\" : 0 , \"NanoCpus\" : 0 , \"CgroupParent\" : \"\" , \"BlkioWeight\" : 0 , \"BlkioWeightDevice\" : [] , \"BlkioDeviceReadBps\" : null, \"BlkioDeviceWriteBps\" : null, \"BlkioDeviceReadIOps\" : null, \"BlkioDeviceWriteIOps\" : null, \"CpuPeriod\" : 0 , \"CpuQuota\" : 0 , \"CpuRealtimePeriod\" : 0 , \"CpuRealtimeRuntime\" : 0 , \"CpusetCpus\" : \"\" , \"CpusetMems\" : \"\" , \"Devices\" : [] , \"DeviceCgroupRules\" : null, \"DeviceRequests\" : null, \"KernelMemory\" : 0 , \"KernelMemoryTCP\" : 0 , \"MemoryReservation\" : 0 , \"MemorySwap\" : 0 , \"MemorySwappiness\" : null, \"OomKillDisable\" : false, \"PidsLimit\" : null, \"Ulimits\" : null, \"CpuCount\" : 0 , \"CpuPercent\" : 0 , \"IOMaximumIOps\" : 0 , \"IOMaximumBandwidth\" : 0 , \"MaskedPaths\" : [ \"/proc/asound\" , \"/proc/acpi\" , \"/proc/kcore\" , \"/proc/keys\" , \"/proc/latency_stats\" , \"/proc/timer_list\" , \"/proc/timer_stats\" , \"/proc/sched_debug\" , \"/proc/scsi\" , \"/sys/firmware\" ] , \"ReadonlyPaths\" : [ \"/proc/bus\" , \"/proc/fs\" , \"/proc/irq\" , \"/proc/sys\" , \"/proc/sysrq-trigger\" ] } , \"GraphDriver\" : { \"Data\" : { \"LowerDir\" : \"/var/lib/docker/overlay2/8b4c0276493d49acf7c85ad47ca5192896e9ea1ea2d2aa3f02d4f2d8eb47f58d-init/diff:/var/lib/docker/overlay2/c1e6aceded10a0b1ebf0c89ed6b382faea13f6a2564b6be59641c91be4da68b3/diff:/var/lib/docker/overlay2/fa16037866db03e19d99c1d3695d6951569e751ba938036bcc1e82e31dad41cb/diff:/var/lib/docker/overlay2/adf9f3208ebac0a1566f031e9404f218349446153d3124c46c96d0db7d1b6097/diff:/var/lib/docker/overlay2/a5121e4e639c611e78ca69f1f5d90d032249852a6927b12968ac7709945f41e4/diff:/var/lib/docker/overlay2/8bf60f425fa90fe22dd757fc45d388c568254b79ec6f5bf724ac6a3a7972af84/diff:/var/lib/docker/overlay2/d75a9d8d1cabc06f29c2d1ea6854083e8de20bec99df58efed06bcbc01a9e0f4/diff\" , \"MergedDir\" : \"/var/lib/docker/overlay2/8b4c0276493d49acf7c85ad47ca5192896e9ea1ea2d2aa3f02d4f2d8eb47f58d/merged\" , \"UpperDir\" : \"/var/lib/docker/overlay2/8b4c0276493d49acf7c85ad47ca5192896e9ea1ea2d2aa3f02d4f2d8eb47f58d/diff\" , \"WorkDir\" : \"/var/lib/docker/overlay2/8b4c0276493d49acf7c85ad47ca5192896e9ea1ea2d2aa3f02d4f2d8eb47f58d/work\" } , \"Name\" : \"overlay2\" } , \"Mounts\" : [] , \"Config\" : { \"Hostname\" : \"2f03f1f2cd10\" , \"Domainname\" : \"\" , \"User\" : \"\" , \"AttachStdin\" : false, \"AttachStdout\" : false, \"AttachStderr\" : false, \"ExposedPorts\" : { \"80/tcp\" : {} } , \"Tty\" : false, \"OpenStdin\" : false, \"StdinOnce\" : false, \"Env\" : [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" , \"NGINX_VERSION=1.21.0\" , \"NJS_VERSION=0.5.3\" , \"PKG_RELEASE=1~buster\" ] , \"Cmd\" : [ \"nginx\" , \"-g\" , \"daemon off;\" ] , \"Image\" : \"nginx\" , \"Volumes\" : null, \"WorkingDir\" : \"\" , \"Entrypoint\" : [ \"/docker-entrypoint.sh\" ] , \"OnBuild\" : null, \"Labels\" : { \"maintainer\" : \"NGINX Docker Maintainers <docker-maint@nginx.com>\" } , \"StopSignal\" : \"SIGQUIT\" } , \"NetworkSettings\" : { \"Bridge\" : \"\" , \"SandboxID\" : \"a74ea121ebf1163153ed7f24fb22b4cc11af77f336cfdbee9252d7c80ed9be0f\" , \"HairpinMode\" : false, \"LinkLocalIPv6Address\" : \"\" , \"LinkLocalIPv6PrefixLen\" : 0 , \"Ports\" : { \"80/tcp\" : null } , \"SandboxKey\" : \"/var/run/docker/netns/a74ea121ebf1\" , \"SecondaryIPAddresses\" : null, \"SecondaryIPv6Addresses\" : null, \"EndpointID\" : \"c3b64e072f7851e3bf55ba3685fa1fbdec6b9c59d18ae27e5e90a1be5728f54c\" , \"Gateway\" : \"172.17.0.1\" , \"GlobalIPv6Address\" : \"\" , \"GlobalIPv6PrefixLen\" : 0 , \"IPAddress\" : \"172.17.0.2\" , \"IPPrefixLen\" : 16 , \"IPv6Gateway\" : \"\" , \"MacAddress\" : \"02:42:ac:11:00:02\" , \"Networks\" : { \"bridge\" : { \"IPAMConfig\" : null, \"Links\" : null, \"Aliases\" : null, \"NetworkID\" : \"0aa786b7de5fbfcd3e18db78511ed544d450bb0ad198cab0244bc8b83d30b514\" , \"EndpointID\" : \"c3b64e072f7851e3bf55ba3685fa1fbdec6b9c59d18ae27e5e90a1be5728f54c\" , \"Gateway\" : \"172.17.0.1\" , \"IPAddress\" : \"172.17.0.2\" , \"IPPrefixLen\" : 16 , \"IPv6Gateway\" : \"\" , \"GlobalIPv6Address\" : \"\" , \"GlobalIPv6PrefixLen\" : 0 , \"MacAddress\" : \"02:42:ac:11:00:02\" , \"DriverOpts\" : null } } } } ] We can also selectively query the inspect results hash using the -f or --format flag. For example, let's retrieve the container network address: docker container inspect -f '{{.NetworkSettings.IPAddress}}' nginx 172.17.0.2","title":"Finding out more about our container"},{"location":"container/health_checks/","text":"Health checks (available since Docker 1.12) allow a container to expose its workload\u2019s availability. This stands apart from whether the container is running. If your database goes down, your API server won\u2019t be able to handle requests, even though its Docker container is still running. When a health check command is specified, it tells Docker how to test the container to see if it's working. With no health check specified, Docker has no way of knowing whether or not the services running within your container are actually up or not. Health checks can be configured in different ways: directly in the docker image (Dockerfile) when you launch your standalone container with docker run (we will cover this case below) or in your docker compose file In all cases, the health check is configured as a command that the docker daemon will execute every 30 seconds (default interval that can be overriden). Docker uses the command\u2019s exit code to determine your container\u2019s healthiness: 0 \u2013 The container is healthy and working normally. 1 \u2013 The container is unhealthy; the workload may not be functioning. 2 \u2013 This status code is reserved by Docker and should not be used. Without health checks, a simple docker ps would report the container as available. Adding a health check extends the docker ps output to include the container\u2019s true state. Health Check Configuration \u00b6 There are a few options that we can use to customize our health check instruction: interval - DURATION (default: 30s) timeout - DURATION (default: 30s) start-period - DURATION (default: 0s) retries - DURATION (default: 3) interval (option: --health-interval , default: 30s) - specifies the time between the health check for the application container. it waits for the specified time from one check to another. timeout (option: --health-timeout , default: 30s) - specifies the time that the health check waits for a response to consider the status of the container. For example, if we define 30 seconds and our server doesn\u2019t respond within 30 seconds, then it\u2019s considered as failed. start-period (option: --health-start-period , default: 0s) - specifies the number of seconds the container needs to start; health check will wait for that time to start. retries (option: --health-retries , default: 3) - specifies the number of consecutive health check failures required to declare the container status as unhealthy. Health check will only try up to the specified retry number. If the server fails consecutively up to the specified times, it is then considered unhealthy. Example \u00b6 We will now add a health check to our nginx container: the check will be implemented using curl command curl --fail http://localhost : docker run --name nginx -d --health-cmd='curl --fail http://localhost:80 || exit 1' nginx The curl command makes a request to localhost:80 and if the request returns the http code 200, it will return exit code 0; otherwise, it will return exit code 1. Look at the container status using docker ps . The container can have three states: starting \u2013 Initial status when the container is still starting healthy \u2013 If the command succeeds then the container is healthy unhealthy \u2013 If a single run of the takes longer than the specified timeout then it is considered unhealthy. If a health check fails then the will run retries number of times and will be declared unhealthy if the still fails. CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ed1a8b6c451e nginx \"/docker-entrypoint.\u2026\" 9 seconds ago Up 7 seconds (health: starting) 80/tcp nginx Initially, it will take some time to start the health check and update, whether the application is healthy or not. After the start period, if the application is healthy you will get: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ed1a8b6c451e nginx \"/docker-entrypoint.\u2026\" 46 seconds ago Up 44 seconds (healthy) 80/tcp nginx You can have a look at the container log and see the requests made to check the health status of the application: docker logs nginx /docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration /docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/ /docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh 10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf 10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf /docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh /docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh /docker-entrypoint.sh: Configuration complete; ready for start up 2022/09/01 13:21:09 [notice] 1#1: using the \"epoll\" event method 2022/09/01 13:21:09 [notice] 1#1: nginx/1.23.1 2022/09/01 13:21:09 [notice] 1#1: built by gcc 10.2.1 20210110 (Debian 10.2.1-6) 2022/09/01 13:21:09 [notice] 1#1: OS: Linux 5.4.0-122-generic 2022/09/01 13:21:09 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576 2022/09/01 13:21:09 [notice] 1#1: start worker processes 2022/09/01 13:21:09 [notice] 1#1: start worker process 30 127.0.0.1 - - [01/Sep/2022:13:21:39 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:22:09 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:22:39 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:23:10 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:23:40 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:24:10 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:24:40 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:25:10 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:25:41 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:26:11 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" As you can see, the check runs every 30s (default) but you can change the interval with the option --health-interval . Now let's remove the index.html file that nginx serves on http://localhost in order to simulate an application failure: docker exec nginx sh -c 'mv /usr/share/nginx/html/index.html /usr/share/nginx/html/index.html.1' Look again at the log: /docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration /docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/ /docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh 10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf 10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf /docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh /docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh /docker-entrypoint.sh: Configuration complete; ready for start up 2022/09/01 13:21:09 [notice] 1#1: using the \"epoll\" event method 2022/09/01 13:21:09 [notice] 1#1: nginx/1.23.1 2022/09/01 13:21:09 [notice] 1#1: built by gcc 10.2.1 20210110 (Debian 10.2.1-6) 2022/09/01 13:21:09 [notice] 1#1: OS: Linux 5.4.0-122-generic 2022/09/01 13:21:09 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576 2022/09/01 13:21:09 [notice] 1#1: start worker processes 2022/09/01 13:21:09 [notice] 1#1: start worker process 30 127.0.0.1 - - [01/Sep/2022:13:21:39 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:22:09 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:22:39 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:23:10 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:23:40 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:24:10 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:24:40 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:25:10 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:25:41 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:26:11 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:26:41 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:27:11 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:27:41 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:28:11 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:28:42 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:29:12 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:29:42 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:30:12 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:30:42 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 2022/09/01 13:31:13 [error] 30#30: *20 directory index of \"/usr/share/nginx/html/\" is forbidden, client: 127.0.0.1, server: localhost, request: \"GET / HTTP/1.1\", host: \"localhost\" 127.0.0.1 - - [01/Sep/2022:13:31:13 +0000] \"GET / HTTP/1.1\" 403 153 \"-\" \"curl/7.74.0\" \"-\" The curl command now returns the http error code 403 and therefore the check returns an exit code 1. Check the status of the container with docker ps : CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ed1a8b6c451e nginx \"/docker-entrypoint.\u2026\" 13 minutes ago Up 13 minutes (unhealthy) 80/tcp nginx The container is now flagged as unhealthy. Exercise Restore the index.html file and verify the container status.","title":"How to add a health check to your docker container"},{"location":"container/health_checks/#health-check-configuration","text":"There are a few options that we can use to customize our health check instruction: interval - DURATION (default: 30s) timeout - DURATION (default: 30s) start-period - DURATION (default: 0s) retries - DURATION (default: 3) interval (option: --health-interval , default: 30s) - specifies the time between the health check for the application container. it waits for the specified time from one check to another. timeout (option: --health-timeout , default: 30s) - specifies the time that the health check waits for a response to consider the status of the container. For example, if we define 30 seconds and our server doesn\u2019t respond within 30 seconds, then it\u2019s considered as failed. start-period (option: --health-start-period , default: 0s) - specifies the number of seconds the container needs to start; health check will wait for that time to start. retries (option: --health-retries , default: 3) - specifies the number of consecutive health check failures required to declare the container status as unhealthy. Health check will only try up to the specified retry number. If the server fails consecutively up to the specified times, it is then considered unhealthy.","title":"Health Check Configuration"},{"location":"container/health_checks/#example","text":"We will now add a health check to our nginx container: the check will be implemented using curl command curl --fail http://localhost : docker run --name nginx -d --health-cmd='curl --fail http://localhost:80 || exit 1' nginx The curl command makes a request to localhost:80 and if the request returns the http code 200, it will return exit code 0; otherwise, it will return exit code 1. Look at the container status using docker ps . The container can have three states: starting \u2013 Initial status when the container is still starting healthy \u2013 If the command succeeds then the container is healthy unhealthy \u2013 If a single run of the takes longer than the specified timeout then it is considered unhealthy. If a health check fails then the will run retries number of times and will be declared unhealthy if the still fails. CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ed1a8b6c451e nginx \"/docker-entrypoint.\u2026\" 9 seconds ago Up 7 seconds (health: starting) 80/tcp nginx Initially, it will take some time to start the health check and update, whether the application is healthy or not. After the start period, if the application is healthy you will get: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ed1a8b6c451e nginx \"/docker-entrypoint.\u2026\" 46 seconds ago Up 44 seconds (healthy) 80/tcp nginx You can have a look at the container log and see the requests made to check the health status of the application: docker logs nginx /docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration /docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/ /docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh 10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf 10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf /docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh /docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh /docker-entrypoint.sh: Configuration complete; ready for start up 2022/09/01 13:21:09 [notice] 1#1: using the \"epoll\" event method 2022/09/01 13:21:09 [notice] 1#1: nginx/1.23.1 2022/09/01 13:21:09 [notice] 1#1: built by gcc 10.2.1 20210110 (Debian 10.2.1-6) 2022/09/01 13:21:09 [notice] 1#1: OS: Linux 5.4.0-122-generic 2022/09/01 13:21:09 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576 2022/09/01 13:21:09 [notice] 1#1: start worker processes 2022/09/01 13:21:09 [notice] 1#1: start worker process 30 127.0.0.1 - - [01/Sep/2022:13:21:39 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:22:09 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:22:39 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:23:10 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:23:40 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:24:10 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:24:40 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:25:10 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:25:41 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:26:11 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" As you can see, the check runs every 30s (default) but you can change the interval with the option --health-interval . Now let's remove the index.html file that nginx serves on http://localhost in order to simulate an application failure: docker exec nginx sh -c 'mv /usr/share/nginx/html/index.html /usr/share/nginx/html/index.html.1' Look again at the log: /docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration /docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/ /docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh 10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf 10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf /docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh /docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh /docker-entrypoint.sh: Configuration complete; ready for start up 2022/09/01 13:21:09 [notice] 1#1: using the \"epoll\" event method 2022/09/01 13:21:09 [notice] 1#1: nginx/1.23.1 2022/09/01 13:21:09 [notice] 1#1: built by gcc 10.2.1 20210110 (Debian 10.2.1-6) 2022/09/01 13:21:09 [notice] 1#1: OS: Linux 5.4.0-122-generic 2022/09/01 13:21:09 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576 2022/09/01 13:21:09 [notice] 1#1: start worker processes 2022/09/01 13:21:09 [notice] 1#1: start worker process 30 127.0.0.1 - - [01/Sep/2022:13:21:39 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:22:09 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:22:39 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:23:10 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:23:40 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:24:10 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:24:40 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:25:10 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:25:41 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:26:11 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:26:41 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:27:11 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:27:41 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:28:11 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:28:42 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:29:12 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:29:42 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:30:12 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 127.0.0.1 - - [01/Sep/2022:13:30:42 +0000] \"GET / HTTP/1.1\" 200 615 \"-\" \"curl/7.74.0\" \"-\" 2022/09/01 13:31:13 [error] 30#30: *20 directory index of \"/usr/share/nginx/html/\" is forbidden, client: 127.0.0.1, server: localhost, request: \"GET / HTTP/1.1\", host: \"localhost\" 127.0.0.1 - - [01/Sep/2022:13:31:13 +0000] \"GET / HTTP/1.1\" 403 153 \"-\" \"curl/7.74.0\" \"-\" The curl command now returns the http error code 403 and therefore the check returns an exit code 1. Check the status of the container with docker ps : CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ed1a8b6c451e nginx \"/docker-entrypoint.\u2026\" 13 minutes ago Up 13 minutes (unhealthy) 80/tcp nginx The container is now flagged as unhealthy. Exercise Restore the index.html file and verify the container status.","title":"Example"},{"location":"container/manipulation/","text":"If you read the output from our hello world , they even recommend what to try next. docker container run -it ubuntu bash Let's see what happens: Unable to find image 'ubuntu:latest' locally latest: Pulling from library/ubuntu 345e3491a907: Pull complete 57671312ef6f: Pull complete 5e9250ddb7d0: Pull complete Digest: sha256:adf73ca014822ad8237623d388cedf4d5346aa72c270c5acc01431cc93e18e2d Status: Downloaded newer image for ubuntu:latest We are inside the docker container! Tip You need to use the -it option whenever you want to run a container in interactive mode. - The -i or --interactive option connects you to the input stream of the container, so that you can send inputs to bash; - The -t or --tty option makes sure that you get some good formatting and a native terminal-like experience by allocating a pseudo-tty. Playing with a running container \u00b6 This is a fully fledged Ubuntu host, and we can do anything we like in it. Let's explore it a bit, starting with asking for its hostname: root@a5a2c01df566:/# hostname a5a2c01df566 We can see that our container's hostname is the container ID. Let's have a look at the /etc/hosts file too. root@a5a2c01df566:/# cat /etc/hosts 127 .0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 172 .17.0.2 a5a2c01df566 Docker has also added a host entry for our container with its IP address. Let's also check out its networking configuration. root@a5a2c01df566:/# ip a 1 : lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00 :00:00:00:00:00 brd 00 :00:00:00:00:00 inet 127 .0.0.1/8 scope host lo valid_lft forever preferred_lft forever 85 : eth0@if86: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default link/ether 02 :42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172 .17.0.2/16 brd 172 .17.255.255 scope global eth0 valid_lft forever preferred_lft forever ip: command not found Install the package iproute2 that provides a collection of utilities for networking and traffic control. apt update && apt install -y iproute2 As we can see, we have the lo loopback interface and the eth0@if86 network interface with an IP address of 172.17.0.2, just like any other host. We can also check its running processes: root@a5a2c01df566:/# ps aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0 .0 0 .0 4216 3588 pts/0 Ss 08 :46 0 :00 bash root 601 0 .0 0 .0 5896 2852 pts/0 R+ 10 :17 0 :00 ps aux Note that the process bash has PID 1. Now type exit or the CTRL-d key sequence...you'll return to the command prompt of your Ubuntu host. So what's happened to our container? The container only runs for as long as the command we specified, /bin/bash , is running. Once we exited the container, that command ended, and the container was stopped. So the container still exists but it's stopped: docker container ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a5a2c01df566 ubuntu \"bash\" 2 hours ago Exited ( 0 ) 6 seconds ago festive_cerf Starting a stopped container \u00b6 We can start again our stopped container with docker container start <container-id or container-name> : docker container start a5a2c01df566 a5a2c01df566 Our container will restart with the same options we had specified when we launched it with the docker run command. Attaching to a container \u00b6 The docker container attach command allows you to attach your terminal to the running container. Tip The command that is executed when starting a container is specified using the ENTRYPOINT and/or CMD instruction in the Dockerfile. The attach command allows you to connect and interact with the container\u2019s main process which has PID 1 . Remember that if you kill the main process the container will terminate . This is useful when you want to see what is written in the standard output in real-time, or to control the process interactively. So running the attach command on our Ubuntu container will bring us back to our bash prompt: docker container attach a5a2c01df566 root@a5a2c01df566:/# You can detach from a container and leave it running using the CTRL-p CTRL-q key sequence. What happens if you type exit ? Getting a shell to a container \u00b6 The docker exec command allows you to run commands inside a running container. The command can be run in background using the option -d or interactively using the option -i . Try the following command on your Ubuntu container: docker exec -it a5a2c01df566 bash root@a5a2c01df566:/# Let's look at the processes inside the container: root@a5a2c01df566:/# ps aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0 .0 0 .0 4108 3420 pts/0 Ss+ 14 :05 0 :00 bash root 9 0 .6 0 .0 4108 3468 pts/1 Ss 14 :06 0 :00 bash root 17 0 .0 0 .0 5896 2848 pts/1 R+ 14 :06 0 :00 ps aux We can see that the exec command started a new shell session. Tip Usually the exec command is used to launch bash within the container and work with that. The attach command primarily is used if you quickly want to see the output of the main process ( PID 1 ) directly and/or want to kill it.","title":"Work with your first container"},{"location":"container/manipulation/#playing-with-a-running-container","text":"This is a fully fledged Ubuntu host, and we can do anything we like in it. Let's explore it a bit, starting with asking for its hostname: root@a5a2c01df566:/# hostname a5a2c01df566 We can see that our container's hostname is the container ID. Let's have a look at the /etc/hosts file too. root@a5a2c01df566:/# cat /etc/hosts 127 .0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 172 .17.0.2 a5a2c01df566 Docker has also added a host entry for our container with its IP address. Let's also check out its networking configuration. root@a5a2c01df566:/# ip a 1 : lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00 :00:00:00:00:00 brd 00 :00:00:00:00:00 inet 127 .0.0.1/8 scope host lo valid_lft forever preferred_lft forever 85 : eth0@if86: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default link/ether 02 :42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172 .17.0.2/16 brd 172 .17.255.255 scope global eth0 valid_lft forever preferred_lft forever ip: command not found Install the package iproute2 that provides a collection of utilities for networking and traffic control. apt update && apt install -y iproute2 As we can see, we have the lo loopback interface and the eth0@if86 network interface with an IP address of 172.17.0.2, just like any other host. We can also check its running processes: root@a5a2c01df566:/# ps aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0 .0 0 .0 4216 3588 pts/0 Ss 08 :46 0 :00 bash root 601 0 .0 0 .0 5896 2852 pts/0 R+ 10 :17 0 :00 ps aux Note that the process bash has PID 1. Now type exit or the CTRL-d key sequence...you'll return to the command prompt of your Ubuntu host. So what's happened to our container? The container only runs for as long as the command we specified, /bin/bash , is running. Once we exited the container, that command ended, and the container was stopped. So the container still exists but it's stopped: docker container ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a5a2c01df566 ubuntu \"bash\" 2 hours ago Exited ( 0 ) 6 seconds ago festive_cerf","title":"Playing with a running container"},{"location":"container/manipulation/#starting-a-stopped-container","text":"We can start again our stopped container with docker container start <container-id or container-name> : docker container start a5a2c01df566 a5a2c01df566 Our container will restart with the same options we had specified when we launched it with the docker run command.","title":"Starting a stopped container"},{"location":"container/manipulation/#attaching-to-a-container","text":"The docker container attach command allows you to attach your terminal to the running container. Tip The command that is executed when starting a container is specified using the ENTRYPOINT and/or CMD instruction in the Dockerfile. The attach command allows you to connect and interact with the container\u2019s main process which has PID 1 . Remember that if you kill the main process the container will terminate . This is useful when you want to see what is written in the standard output in real-time, or to control the process interactively. So running the attach command on our Ubuntu container will bring us back to our bash prompt: docker container attach a5a2c01df566 root@a5a2c01df566:/# You can detach from a container and leave it running using the CTRL-p CTRL-q key sequence. What happens if you type exit ?","title":"Attaching to a container"},{"location":"container/manipulation/#getting-a-shell-to-a-container","text":"The docker exec command allows you to run commands inside a running container. The command can be run in background using the option -d or interactively using the option -i . Try the following command on your Ubuntu container: docker exec -it a5a2c01df566 bash root@a5a2c01df566:/# Let's look at the processes inside the container: root@a5a2c01df566:/# ps aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0 .0 0 .0 4108 3420 pts/0 Ss+ 14 :05 0 :00 bash root 9 0 .6 0 .0 4108 3468 pts/1 Ss 14 :06 0 :00 bash root 17 0 .0 0 .0 5896 2848 pts/1 R+ 14 :06 0 :00 ps aux We can see that the exec command started a new shell session. Tip Usually the exec command is used to launch bash within the container and work with that. The attach command primarily is used if you quickly want to see the output of the main process ( PID 1 ) directly and/or want to kill it.","title":"Getting a shell to a container"},{"location":"data/volume_plugin/","text":"Docker Engine volume plugins enable Engine deployments to be integrated with external storage systems such as NFS, Ceph, Openstack Cinder, Amazon EBS, and enable data volumes to persist beyond the lifetime of a single Docker host. This section will show an example using the Netshare docker volume plugin to mount NFS shares inside our container. Note Netshare is a Docker volume plugin for NFS 3/4, EFS and CIFS/SMB. We will show its usage with NFS as an example. However consider that you can attach NFS volumes to docker containers using the local driver as well since docker provides natively the support for NFS. For example: # docker volume create --driver local --opt type=nfs --opt o=addr=<nfs server ip>,rw --opt device=:<export nfs path> <volume name> The plugin has been installed following the instructions provided in the docs . The NFS server has been installed on the machine with IP 192.168.28.53 and configured to export the path /mnt/nfs_share/nginx : Export list for 192 .168.28.53: /mnt/nfs_share/nginx 192 .168.28.151 You can check that the docker plugin service is up and running on the docker host: sudo systemctl status docker-volume-netshare \u25cf docker-volume-netshare.service - LSB: Init for docker-volume-netshare Loaded: loaded ( /etc/init.d/docker-volume-netshare ; generated ) Active: active ( running ) since Sun 2021 -06-13 13 :23:58 UTC ; 1h 6min ago Docs: man:systemd-sysv-generator ( 8 ) Process: 716471 ExecStart = /etc/init.d/docker-volume-netshare start ( code = exited, status = 0 /SUCCESS ) Tasks: 5 ( limit: 4683 ) Memory: 6 .3M CGroup: /system.slice/docker-volume-netshare.service \u2514\u2500716480 /usr/bin/docker-volume-netshare nfs Jun 13 13 :23:58 tutorvm-1 systemd [ 1 ] : Starting LSB: Init for docker-volume-netshare... Jun 13 13 :23:58 tutorvm-1 docker-volume-netshare [ 716471 ] : * Starting Docker-Volume-Netshare: docker-volume-netshare Jun 13 13 :23:58 tutorvm-1 docker-volume-netshare [ 716471 ] : ...done. Jun 13 13 :23:58 tutorvm-1 systemd [ 1 ] : Started LSB: Init for docker-volume-netshare. Launch the nginx container with an NFS docker volume: docker run -d -p 8081 :80 --name nginx_nfs --volume-driver = nfs -v 192 .168.28.53/mnt/nfs_share/nginx:/usr/share/nginx/html nginx Check the volume list: docker volume ls DRIVER VOLUME NAME nfs 192 .168.28.53/mnt/nfs_share/nginx Inspect the volume: docker inspect 192 .168.28.53/mnt/nfs_share/nginx [ { \"CreatedAt\" : \"0001-01-01T00:00:00Z\" , \"Driver\" : \"nfs\" , \"Labels\" : null, \"Mountpoint\" : \"/var/lib/docker-volumes/netshare/nfs/192.168.28.53/mnt/nfs_share/nginx\" , \"Name\" : \"192.168.28.53/mnt/nfs_share/nginx\" , \"Options\" : null, \"Scope\" : \"local\" } ] The plugin has automatically mounted the NFS volume on your docker host...look at the mounts: sudo mount | grep nginx 192 .168.28.53:/mnt/nfs_share/nginx on /var/lib/docker-volumes/netshare/nfs/192.168.28.53/mnt/nfs_share/nginx type nfs4 ( rw,relatime,vers = 4 .2,rsize = 524288 ,wsize = 524288 ,namlen = 255 ,hard,proto = tcp,timeo = 600 ,retrans = 2 ,sec = sys,clientaddr = 192 .168.28.151,local_lock = none,addr = 192 .168.28.53 ) Now connect to the deployed service ( nginx ) on port 8081 :","title":"Volume plugin"},{"location":"data/volume_summary/","text":"","title":"Summary"},{"location":"data/volumes/","text":"Whenever a running container wants to write data, it actually put that data into the writable layer through a storage driver. We will now do some tasks using volumes. Let's create a volume: Command Output docker volume create volume1 volume1 and check that the volume has been created: Command Output docker volume ls DRIVER VOLUME NAME local volume1 Let's do the same with a second volume: Command Output docker volume create volume2 volume2 and check: Command Output docker volume ls DRIVER VOLUME NAME local volume1 local volume2 Let's now remove the second volume we've created: Command Output docker volume rm volume2 volume2 and check that it has actually been removed Command Output docker volume ls DRIVER VOLUME NAME local volume1 Now let's dive into real-life (or quasi-real-life) usage of Docker volumes. Let's use our nginx2 container created previously. Tip If you don't have this container running you can recreate it with the following command: docker container run -d -p 80:80 --name nginx2 nginx Let\u2019s use the docker exec command to edit the welcome page and load it. docker container exec -it nginx2 bash This wil open a bash shell and now you should now be inside your container. Run the following command to change the welcome page: echo \"I changed the content of this file inside the running container...\" > /usr/share/nginx/html/index.html You will be able to see these changes connecting to the port 80 of your host: Let\u2019s restart the container: docker container restart nginx2 What happens? We can still see in the browser the changes that we made. Now... what if we stop this container and start another one and load the page? docker container run -d -p 8080 :80 --name nginx3 nginx Warning For this second container you need to specify a different host port, otherwise there will be a conflict and your container will not be started: driver failed programming external connectivity on endpoint nginx3 (96fad8e096e1a124147049765f0d734e2a034712fb253711450c62a7158b1f21): Bind for 0.0.0.0:80 failed: port is already allocated. Connect to port 8080 of your host, you will see the default welcome page: there is no way that we could access the file that we have changed in another container. Using docker volumes \u00b6 Let's now create a docker volume to be used with our nginx container: docker volume create myvol We can see the location of volumes in the docker area of the host file system with the inspect command: docker volume inspect myvol whose output contains the following information: [ { \"CreatedAt\" : \"2021-06-07T10:53:26Z\" , \"Driver\" : \"local\" , \"Labels\" : {} , \"Mountpoint\" : \"/var/lib/docker/volumes/myvol/_data\" , \"Name\" : \"myvol\" , \"Options\" : {} , \"Scope\" : \"local\" } ] Let's re-create our nginx container with the following command that mounts the volume myvol in /usr/share/nginx/html : Remove the old container (please note that the -f or --force flag is needed to delete a running container; otherwise, we should docker container stop nginx3 first, then docker container rm nginx3 ): docker container rm -f nginx3 Recreate it with the volume mounted, using the --mount directive as in the following: docker container run -d -p 8080 :80 --name nginx3 --mount type = volume,source = myvol,destination = /usr/share/nginx/html nginx Note if we hadn\u2019t create the volume earlier, docker would have created it for us with the name given in source field of --mount parameter remember that volumes are not deleted when we erase the container which they are attached to if the container has got in target directory any files, this files will be copied into the volume Now let's enter the container and modify the welcome page (the index.html file served by nginx by default, located at /usr/share/nginx/html/index.html inside the container): docker exec -it nginx3 bash Once inside the container, run the following command: echo \"I've changed the content of this file in the docker volume\" > /usr/share/nginx/html/index.html Let' stop and remove this container:: docker rm -f nginx3 and create a new one with the same command: docker container run -d -p 8080 :80 --name nginx3 --mount type = volume,source = myvol,destination = /usr/share/nginx/html nginx If we load the page again we will still see the html file that we edited in the volume. Now let's create another container sharing the same volume (we will now use port 8081, in order not to clash with the previous container): docker container run -d -p 8081 :80 --name nginx3-2 --mount type = volume,source = myvol,destination = /usr/share/nginx/html nginx then check that we see the same content: curl 192 .168.28.151:8081 Using bind mounts \u00b6 Now we will create a container running nginx using a bind mount (with the type=bind directive) for the main served directory instead of a volume. Note if we didn\u2019t create a directory on docker host earlier docker will not create it for us with --mount parameter, auto-creating is available only in older --volume bind mounts by default will not be deleted while removing the container if the container has got in target directory any files, this files will NOT be copied into bind mount directory, bind directory will cover any files in a target container directory Try the following command: docker container run -d -p 8088 :80 --name nginx4 --mount type = bind,source = /tmp/nginx,destination = /usr/share/nginx/html nginx You will get an error since the path /tmp/nginx does not exist on the host: docker: Error response from daemon: invalid mount config for type \"bind\": bind source path does not exist: /tmp/nginx. See 'docker run --help'. Let's create the directory on the host: mkdir /tmp/nginx Now re-run the command for creating the container with the /usr/share/nginx/html directory mapped to the local (on the host) /tmp/nginx : docker container run -d -p 8088 :80 --name nginx4 --mount type = bind,source = /tmp/nginx,destination = /usr/share/nginx/html nginx If you inspect the container: docker container inspect nginx4 you will see the bind-mount: ... \"Mounts\" : [ { \"Type\" : \"bind\" , \"Source\" : \"/tmp/nginx\" , \"Target\" : \"/usr/share/nginx/html\" } ] , ... Connect to port 8088 on the host IP to see the result: As you can see we get an error message from nginx as the bind-mount has overwritten the content of /usr/share/nginx/html (remember that the behaviour with docker volumes is different, any file inside the container is copied in the volume) Let's now create the index.html file in the host path /tmp/nginx : echo \"I've changed the content of this file on the host\" > /tmp/nginx/index.html Then reload the page in the browser: Question As done before, try to remove the container and recreate it with the same bind-mount...what happens? Lab challenge \u00b6 Goal : create a service based on two containers: WordPress MySQL and then use your web browser to access wordpress on port 8080. Tip Create a volume db_data to provide persistent storage for the DBMS Launch MySQL (image name: mysql:5.7 ) with container name db , using the previously created volume, and pass environment variables to the container to configure it Inspect the MySQL container finding its private IP Launch WordPress (image name: wordpress:latest ) with container name wordpress , and pass environment variables to the container to configure it (using as db host the IP of the MySQL container).","title":"Docker volumes and bind-mounts"},{"location":"data/volumes/#using-docker-volumes","text":"Let's now create a docker volume to be used with our nginx container: docker volume create myvol We can see the location of volumes in the docker area of the host file system with the inspect command: docker volume inspect myvol whose output contains the following information: [ { \"CreatedAt\" : \"2021-06-07T10:53:26Z\" , \"Driver\" : \"local\" , \"Labels\" : {} , \"Mountpoint\" : \"/var/lib/docker/volumes/myvol/_data\" , \"Name\" : \"myvol\" , \"Options\" : {} , \"Scope\" : \"local\" } ] Let's re-create our nginx container with the following command that mounts the volume myvol in /usr/share/nginx/html : Remove the old container (please note that the -f or --force flag is needed to delete a running container; otherwise, we should docker container stop nginx3 first, then docker container rm nginx3 ): docker container rm -f nginx3 Recreate it with the volume mounted, using the --mount directive as in the following: docker container run -d -p 8080 :80 --name nginx3 --mount type = volume,source = myvol,destination = /usr/share/nginx/html nginx Note if we hadn\u2019t create the volume earlier, docker would have created it for us with the name given in source field of --mount parameter remember that volumes are not deleted when we erase the container which they are attached to if the container has got in target directory any files, this files will be copied into the volume Now let's enter the container and modify the welcome page (the index.html file served by nginx by default, located at /usr/share/nginx/html/index.html inside the container): docker exec -it nginx3 bash Once inside the container, run the following command: echo \"I've changed the content of this file in the docker volume\" > /usr/share/nginx/html/index.html Let' stop and remove this container:: docker rm -f nginx3 and create a new one with the same command: docker container run -d -p 8080 :80 --name nginx3 --mount type = volume,source = myvol,destination = /usr/share/nginx/html nginx If we load the page again we will still see the html file that we edited in the volume. Now let's create another container sharing the same volume (we will now use port 8081, in order not to clash with the previous container): docker container run -d -p 8081 :80 --name nginx3-2 --mount type = volume,source = myvol,destination = /usr/share/nginx/html nginx then check that we see the same content: curl 192 .168.28.151:8081","title":"Using docker volumes"},{"location":"data/volumes/#using-bind-mounts","text":"Now we will create a container running nginx using a bind mount (with the type=bind directive) for the main served directory instead of a volume. Note if we didn\u2019t create a directory on docker host earlier docker will not create it for us with --mount parameter, auto-creating is available only in older --volume bind mounts by default will not be deleted while removing the container if the container has got in target directory any files, this files will NOT be copied into bind mount directory, bind directory will cover any files in a target container directory Try the following command: docker container run -d -p 8088 :80 --name nginx4 --mount type = bind,source = /tmp/nginx,destination = /usr/share/nginx/html nginx You will get an error since the path /tmp/nginx does not exist on the host: docker: Error response from daemon: invalid mount config for type \"bind\": bind source path does not exist: /tmp/nginx. See 'docker run --help'. Let's create the directory on the host: mkdir /tmp/nginx Now re-run the command for creating the container with the /usr/share/nginx/html directory mapped to the local (on the host) /tmp/nginx : docker container run -d -p 8088 :80 --name nginx4 --mount type = bind,source = /tmp/nginx,destination = /usr/share/nginx/html nginx If you inspect the container: docker container inspect nginx4 you will see the bind-mount: ... \"Mounts\" : [ { \"Type\" : \"bind\" , \"Source\" : \"/tmp/nginx\" , \"Target\" : \"/usr/share/nginx/html\" } ] , ... Connect to port 8088 on the host IP to see the result: As you can see we get an error message from nginx as the bind-mount has overwritten the content of /usr/share/nginx/html (remember that the behaviour with docker volumes is different, any file inside the container is copied in the volume) Let's now create the index.html file in the host path /tmp/nginx : echo \"I've changed the content of this file on the host\" > /tmp/nginx/index.html Then reload the page in the browser: Question As done before, try to remove the container and recreate it with the same bind-mount...what happens?","title":"Using bind mounts"},{"location":"data/volumes/#lab-challenge","text":"Goal : create a service based on two containers: WordPress MySQL and then use your web browser to access wordpress on port 8080. Tip Create a volume db_data to provide persistent storage for the DBMS Launch MySQL (image name: mysql:5.7 ) with container name db , using the previously created volume, and pass environment variables to the container to configure it Inspect the MySQL container finding its private IP Launch WordPress (image name: wordpress:latest ) with container name wordpress , and pass environment variables to the container to configure it (using as db host the IP of the MySQL container).","title":"Lab challenge"},{"location":"gui/portainer/","text":"Portainer is a lightweight management UI which allows you to easily manage your different Docker environments (Docker hosts or Swarm clusters). Portainer is meant to be as simple to deploy as it is to use. It consists of a single container that can run on any Docker engine. Installation \u00b6 docker volume create portainer_data docker run -d -p 9000 :9000 --name = portainer --restart = always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce Usage \u00b6 The UI will be exposed on port 9000 and you will be asked to create the initial administrator setting a password: Then choose to manage the local Docker environment and click on Connect: If everything works as expected, You will then be shown the Portainer home page: In the menu clicking on Dashboard will open a summary view of your docker engine: Clicking on Containers will allow you to manage containers: Then click on one running container to get the container status and menu from which you can see the log and statistics: Exercise Now go back to the Containers page and try to add a new container.","title":"Portainer"},{"location":"gui/portainer/#installation","text":"docker volume create portainer_data docker run -d -p 9000 :9000 --name = portainer --restart = always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce","title":"Installation"},{"location":"gui/portainer/#usage","text":"The UI will be exposed on port 9000 and you will be asked to create the initial administrator setting a password: Then choose to manage the local Docker environment and click on Connect: If everything works as expected, You will then be shown the Portainer home page: In the menu clicking on Dashboard will open a summary view of your docker engine: Clicking on Containers will allow you to manage containers: Then click on one running container to get the container status and menu from which you can see the log and statistics: Exercise Now go back to the Containers page and try to add a new container.","title":"Usage"},{"location":"image/cacheimages/cache-dangling/","text":"Let's do a quick check on our docker system: docker images REPOSITORY TAG IMAGE ID CREATED SIZE test latest 259e2e6b1ac1 7 minutes ago 101MB <none> <none> 589c6427b137 7 minutes ago 101MB ubuntu 18.04 81bcf752ac3d 3 weeks ago 63.1MB gcr.io/k8s-minikube/kicbase v0.0.22 bcd131522525 5 weeks ago 1.09GB we should wonder what are the images with a <none> tag, you can see when you list all the images present on your system Tip Spolinig: these are dagnling images One thing more: docker images -a REPOSITORY TAG IMAGE ID CREATED SIZE test latest 259e2e6b1ac1 7 minutes ago 101MB <none> <none> 589c6427b137 7 minutes ago 101MB <none> <none> e63fa5024b8d 7 minutes ago 101MB <none> <none> 24a0ae7fb9f2 7 minutes ago 101MB <none> <none> 333abd901bf3 7 minutes ago 99.7MB ubuntu 18.04 81bcf752ac3d 3 weeks ago 63.1MB gcr.io/k8s-minikube/kicbase v0.0.22 bcd131522525 5 weeks ago 1.09GB again: why there are these images with a <none> tag, you can see when you list all the images present on your system Tip Spolinig: these are intermediate cached images Let's clean-up all our docker environment and use our previusly developed Dockerfile to package the application docker system prune Be carefull! this wil clean-up a lot: all stopped containers all networks not used by at least one container all dangling images all dangling build cache there are other way to select what to remove see here [REF] Tip docker rmi $(docker images -a --filter=dangling=true -q) docker rm $(docker ps --filter=status=exited --filter=status=created -q) once we have cleaned our system we will get something like the following: $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE gcr.io/k8s-minikube/kicbase v0.0.22 bcd131522525 5 weeks ago 1.09GB ubuntu latest 7e0aa2d69a15 7 weeks ago 72.7MB $ docker images -a REPOSITORY TAG IMAGE ID CREATED SIZE gcr.io/k8s-minikube/kicbase v0.0.22 bcd131522525 5 weeks ago 1.09GB ubuntu latest 7e0aa2d69a15 7 weeks ago 72.7MB tutor5@tutorvm-5:~/myimage$ this is time now to build our application. So let's start again with our Dockerfile: FROM ubuntu:18.04 RUN apt-get update RUN apt-get install -y figlet ENTRYPOINT [\"figlet\", \"-f\", \"script\"] CMD [\"pippo\"] Now we can build it and we will get something like this: docker build -t testnone . Sending build context to Docker daemon 2.048kB Step 1/5 : FROM ubuntu:18.04 18.04: Pulling from library/ubuntu 4bbfd2c87b75: Pull complete d2e110be24e1: Pull complete 889a7173dcfe: Pull complete Digest: sha256:67b730ece0d34429b455c08124ffd444f021b81e06fa2d9cd0adaf0d0b875182 Status: Downloaded newer image for ubuntu:18.04 ---> 81bcf752ac3d Step 2/5 : RUN apt-get update ---> Running in 80bb3a4b5a8c ... ( remove output ) Reading package lists... Removing intermediate container 80bb3a4b5a8c ---> e095319ffe18 Step 3/5 : RUN apt-get install figlet ---> Running in 30b20940a069 .... ( remove output ) Removing intermediate container 30b20940a069 ---> 9ad1cce70073 Step 4/5 : ENTRYPOINT [\"figlet\", \"-f\", \"script\"] ---> Running in 911a64ae9765 Removing intermediate container 911a64ae9765 ---> cca054892aec Step 5/5 : CMD [\"pippo\"] ---> Running in 67d507ed70c0 Removing intermediate container 67d507ed70c0 ---> f0684153d22f Successfully built f0684153d22f Successfully tagged testnone:latest and let's check again our system: tutor5@tutorvm-5:~/myimage$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE testnone latest f0684153d22f About a minute ago 101MB ubuntu 18.04 81bcf752ac3d 3 weeks ago 63.1MB gcr.io/k8s-minikube/kicbase v0.0.22 bcd131522525 5 weeks ago 1.09GB ubuntu latest 7e0aa2d69a15 7 weeks ago 72.7MB alright but then if I check further: tutor5@tutorvm-5:~/myimage$ docker images -a REPOSITORY TAG IMAGE ID CREATED SIZE testnone latest f0684153d22f About a minute ago 101MB <none> <none> cca054892aec About a minute ago 101MB <none> <none> 9ad1cce70073 About a minute ago 101MB <none> <none> e095319ffe18 2 minutes ago 99.7MB ubuntu 18.04 81bcf752ac3d 3 weeks ago 63.1MB gcr.io/k8s-minikube/kicbase v0.0.22 bcd131522525 5 weeks ago 1.09GB ubuntu latest 7e0aa2d69a15 7 weeks ago 72.7MB where those come from ? Those are the intermediate images genereated while building our image: Removing intermediate container 80bb3a4b5a8c ---> e095319ffe18 Step 3/5 : RUN apt-get install figlet ---> Running in 30b20940a069 .... ( remove output ) Removing intermediate container 30b20940a069 ---> 9ad1cce70073 Step 4/5 : ENTRYPOINT [\"figlet\", \"-f\", \"script\"] ---> Running in 911a64ae9765 Removing intermediate container 911a64ae9765 ---> cca054892aec a container is run changes corresponding to the instruction defined in the step are done inside of this container the container is committed into an image (that is an intermediate image) that will be used as the base image of the next step Now the last step.. let's change our build starting from the previous Dockerfile and changing it: FROM ubuntu:18.04 RUN apt-get update RUN apt-get install -y figlet ENTRYPOINT [ \"figlet\" , \"-f\" , \"script\" ] CMD [ \"ciccio\" ] <---- build it as we did before: docker build -t testnone . Sending build context to Docker daemon 2.048kB Step 1/5 : FROM ubuntu:18.04 ---> 81bcf752ac3d Step 2/5 : RUN apt-get update ---> Using cache ---> e095319ffe18 Step 3/5 : RUN apt-get install figlet ---> Using cache ---> 9ad1cce70073 Step 4/5 : ENTRYPOINT [\"figlet\", \"-f\", \"script\"] ---> Using cache ---> cca054892aec Step 5/5 : CMD [\"Ciccio\"] ---> Running in 976759d6217c Removing intermediate container 976759d6217c ---> 3624cff02928 Successfully built 3624cff02928 Successfully tagged testnone:latest and now check again your images.. docker images REPOSITORY TAG IMAGE ID CREATED SIZE testnone latest 3624cff02928 4 seconds ago 101MB <none> <none> f0684153d22f 17 minutes ago 101MB ubuntu 18.04 81bcf752ac3d 3 weeks ago 63.1MB gcr.io/k8s-minikube/kicbase v0.0.22 bcd131522525 5 weeks ago 1.09GB ubuntu latest 7e0aa2d69a15 7 weeks ago 72.7MB Now, this IMAGE ID f0684153d22f is not more linked to the image named testnone cause the second build has set it on the newly created image (the one containing the changes we did in Dockerfile) The previous image, now considered as dangling, is not referenced anymore. We can remove it, but we probably first need to make sure we have not used the same tag in the second build by mistake (that happens :) ) If needed, you can tag again the dandling image any other image ( we saw it previously ) Finally, in order to check ( and possibly remove ) the dangling images you can play with something like this: docker images -a --filter = dangling = true","title":"... or what are those nasty <none> tags"},{"location":"image/dockerfile/cmd-entrypoint/","text":"CMD and ENTRYPOINT are the commands that allow us to set the default command to run in a container. Adding CMD to our Dockerfile \u00b6 As example: we want to se a nice hello message, and using a custom font in our docker container, for that reason we will execute: figlet -f script hello Tip -f script tells figlet to use a fancy font. hello is the message that we want it to display. Let's modify our Dockerfile to support this default: FROM ubuntu RUN apt-get update RUN apt-get install -y figlet CMD figlet -f script hello and let's build it again : docker build -t myfiglet . This time you will see the effect of the cache and the output is the following: Sending build context to Docker daemon 2.048kB Step 1/4 : FROM ubuntu:18.04 ---> 81bcf752ac3d Step 2/4 : RUN apt-get update ---> Using cache ---> e2ed94338e24 Step 3/4 : RUN apt-get install figlet ---> Using cache ---> d9c8c229f154 Step 4/4 : CMD figlet -f script hello ---> Running in a9f4bc819ea7 Removing intermediate container a9f4bc819ea7 ---> e14a6ebfbd5e Successfully built e14a6ebfbd5e Successfully tagged myfiglet:latest Run it: docker run -ti myfiglet The output will looks like the following: _ _ _ | | | | | | | | _ | | | | __ |/ \\ |/ |/ |/ / \\_ | |_/|__/|__/|__/\\__/ Overriding CMD \u00b6 If we want to get a shell into our container (instead of running figlet), we just have to specify a different program to run. If we aspecify bash , it will replace the value of CMD . Try it: docker run -it myfiglet bash Using ENTRYPOINT \u00b6 And what about if We want to be able to specify a different message on the command line, while retaining figlet and some default parameters? Example: we would like to be able to do this: docker run myfiglet Good Morning We will use the ENTRYPOINT verb in Dockerfile FROM ubuntu RUN apt-get update RUN apt-get install -y figlet ENTRYPOINT [ \"figlet\" , \"-f\" , \"script\" ] Tip ENTRYPOINT defines a base command (and its parameters) for the container. The command line arguments are appended to those parameters. Like CMD, ENTRYPOINT can appear anywhere, and replaces the previous value. When CMD or ENTRYPOINT use string syntax, they get wrapped in sh -c and it would run the following command in the figlet image: sh -c \"figlet -f script\" salut To avoid this wrapping, we can use JSON syntax. Let's build and test: docker build -t myfiglet . and run: docker run myfiglet pippo o _ _ _ __ |/ \\_| |/ \\_|/ \\_/ \\_ |__/ |_/|__/ |__/ \\__/ /| /| /| \\| \\| \\| If we want to run a shell in our container, We cannot just do docker run myfiglet bash because that would just tell figlet to display the word \"bash.\" We use the --entrypoint parameter: $ docker run -it --entrypoint bash myfiglet root@6027e44e2955:/# Combine CMD and ENTRYPOINT \u00b6 What if we want to define a default message for our container? Then we will use ENTRYPOINT and CMD together. ENTRYPOINT will define the base command for our container. CMD will define the default parameter(s) for this command. They both have to use JSON syntax. ENTRYPOINT defines a base command (and its parameters) for the container. If we don't specify extra command-line arguments when starting the container, the value of CMD is appended. Otherwise, our extra command-line arguments are used instead of CMD. FROM ubuntu:18.04 RUN apt-get update RUN apt-get install -y figlet ENTRYPOINT [ \"figlet\" , \"-f\" , \"script\" ] CMD [ \"ciccio\" ] Tip Finally CMD and ENTRYPOINT recap - docker run myimage executes ENTRYPOINT + CMD - docker run myimage args executes ENTRYPOINT + args (overriding CMD) - docker run --entrypoint prog myimage executes prog (overriding both)","title":"The CMD and ENTRYPOINT verbs"},{"location":"image/dockerfile/cmd-entrypoint/#adding-cmd-to-our-dockerfile","text":"As example: we want to se a nice hello message, and using a custom font in our docker container, for that reason we will execute: figlet -f script hello Tip -f script tells figlet to use a fancy font. hello is the message that we want it to display. Let's modify our Dockerfile to support this default: FROM ubuntu RUN apt-get update RUN apt-get install -y figlet CMD figlet -f script hello and let's build it again : docker build -t myfiglet . This time you will see the effect of the cache and the output is the following: Sending build context to Docker daemon 2.048kB Step 1/4 : FROM ubuntu:18.04 ---> 81bcf752ac3d Step 2/4 : RUN apt-get update ---> Using cache ---> e2ed94338e24 Step 3/4 : RUN apt-get install figlet ---> Using cache ---> d9c8c229f154 Step 4/4 : CMD figlet -f script hello ---> Running in a9f4bc819ea7 Removing intermediate container a9f4bc819ea7 ---> e14a6ebfbd5e Successfully built e14a6ebfbd5e Successfully tagged myfiglet:latest Run it: docker run -ti myfiglet The output will looks like the following: _ _ _ | | | | | | | | _ | | | | __ |/ \\ |/ |/ |/ / \\_ | |_/|__/|__/|__/\\__/","title":"Adding CMD to our Dockerfile"},{"location":"image/dockerfile/cmd-entrypoint/#overriding-cmd","text":"If we want to get a shell into our container (instead of running figlet), we just have to specify a different program to run. If we aspecify bash , it will replace the value of CMD . Try it: docker run -it myfiglet bash","title":"Overriding CMD"},{"location":"image/dockerfile/cmd-entrypoint/#using-entrypoint","text":"And what about if We want to be able to specify a different message on the command line, while retaining figlet and some default parameters? Example: we would like to be able to do this: docker run myfiglet Good Morning We will use the ENTRYPOINT verb in Dockerfile FROM ubuntu RUN apt-get update RUN apt-get install -y figlet ENTRYPOINT [ \"figlet\" , \"-f\" , \"script\" ] Tip ENTRYPOINT defines a base command (and its parameters) for the container. The command line arguments are appended to those parameters. Like CMD, ENTRYPOINT can appear anywhere, and replaces the previous value. When CMD or ENTRYPOINT use string syntax, they get wrapped in sh -c and it would run the following command in the figlet image: sh -c \"figlet -f script\" salut To avoid this wrapping, we can use JSON syntax. Let's build and test: docker build -t myfiglet . and run: docker run myfiglet pippo o _ _ _ __ |/ \\_| |/ \\_|/ \\_/ \\_ |__/ |_/|__/ |__/ \\__/ /| /| /| \\| \\| \\| If we want to run a shell in our container, We cannot just do docker run myfiglet bash because that would just tell figlet to display the word \"bash.\" We use the --entrypoint parameter: $ docker run -it --entrypoint bash myfiglet root@6027e44e2955:/#","title":"Using ENTRYPOINT"},{"location":"image/dockerfile/cmd-entrypoint/#combine-cmd-and-entrypoint","text":"What if we want to define a default message for our container? Then we will use ENTRYPOINT and CMD together. ENTRYPOINT will define the base command for our container. CMD will define the default parameter(s) for this command. They both have to use JSON syntax. ENTRYPOINT defines a base command (and its parameters) for the container. If we don't specify extra command-line arguments when starting the container, the value of CMD is appended. Otherwise, our extra command-line arguments are used instead of CMD. FROM ubuntu:18.04 RUN apt-get update RUN apt-get install -y figlet ENTRYPOINT [ \"figlet\" , \"-f\" , \"script\" ] CMD [ \"ciccio\" ] Tip Finally CMD and ENTRYPOINT recap - docker run myimage executes ENTRYPOINT + CMD - docker run myimage args executes ENTRYPOINT + args (overriding CMD) - docker run --entrypoint prog myimage executes prog (overriding both)","title":"Combine CMD and ENTRYPOINT"},{"location":"image/dockerfile/copy/","text":"This section is about another Dockerfile keyword: COPY . During the previous sections we have installed things in our container images by downloading packages. In the real life we might also do something slightly different such as: copy files from the build context to the container that we are building. Tip Remember: the build context is the directory containing the Dockerfile. Build some C code \u00b6 In the following simple example we want to build a container that compiles a basic \"Hello world\" program in C. Example, a hello.c: int main () { puts ( \"Hello, world!\" ); return 0 ; } We can create a new directory, and put this file in there. Then we will write the Dockerfile and we will use COPY to place the source file into the container Tip On Debian and Ubuntu, the package build-essential will get us a compiler. When installing it, don't forget to specify the -y flag, otherwise the build will fail (since the build cannot be interactive). FROM ubuntu RUN apt-get update RUN apt-get install -y build-essential COPY hello.c / RUN make hello CMD /hello Exercise: Create hello.c and Dockerfile in the same directory: Run docker build -t hello . in this directory. Run docker run hello, you should see Hello, world!. COPY and the build cache \u00b6 Docker can cache steps involving COPY. Those steps will not be executed again if the files haven't been changed. You can try it yourself by - Run the build again, but now modify hello.c The .dockerignore file \u00b6 Something you need to take care of is to avoid copy of unneeded files i.e. files in your context but not required in the image. To do that you have a handle: .dockerignore You can create it at the top-level of the build context specifying file names and globs to ignore They won't be sent to the builder and won't end up in the resulting image See the documentation for the little details","title":"Copying files during the build"},{"location":"image/dockerfile/copy/#build-some-c-code","text":"In the following simple example we want to build a container that compiles a basic \"Hello world\" program in C. Example, a hello.c: int main () { puts ( \"Hello, world!\" ); return 0 ; } We can create a new directory, and put this file in there. Then we will write the Dockerfile and we will use COPY to place the source file into the container Tip On Debian and Ubuntu, the package build-essential will get us a compiler. When installing it, don't forget to specify the -y flag, otherwise the build will fail (since the build cannot be interactive). FROM ubuntu RUN apt-get update RUN apt-get install -y build-essential COPY hello.c / RUN make hello CMD /hello Exercise: Create hello.c and Dockerfile in the same directory: Run docker build -t hello . in this directory. Run docker run hello, you should see Hello, world!.","title":"Build some C code"},{"location":"image/dockerfile/copy/#copy-and-the-build-cache","text":"Docker can cache steps involving COPY. Those steps will not be executed again if the files haven't been changed. You can try it yourself by - Run the build again, but now modify hello.c","title":"COPY and the build cache"},{"location":"image/dockerfile/copy/#the-dockerignore-file","text":"Something you need to take care of is to avoid copy of unneeded files i.e. files in your context but not required in the image. To do that you have a handle: .dockerignore You can create it at the top-level of the build context specifying file names and globs to ignore They won't be sent to the builder and won't end up in the resulting image See the documentation for the little details","title":"The .dockerignore file"},{"location":"image/dockerfile/exercise/","text":"The main objective of the exercise is to add a Dockerfile to a Python App. So we have an application and we are asked to do the following: * we need to create a Dockerfile that runs our python application and expose on a well defined port, let's say the 9000. On that port the app will return the environment variable ENVIRONMENT=production ( unless we will ask to return something different ) Tip You can get the files needed to complete the exercise either from git git clone https://github.com/spigad/simple-exercise.git or just cut&paste the code here below. The App \u00b6 A simple python3 API that only responds at / . It returns the value of the ENVIRONMENT environment var as JSON. from flask import Flask import os import sys app = Flask ( __name__ ) @app . route ( \"/\" ) def index (): env = os . getenv ( \"ENVIRONMENT\" , None ) return { \"env\" : env } if __name__ == \"__main__\" : if len ( sys . argv ) < 2 : print ( \"Needs port number as a commandline argument.\" ) sys . exit ( 1 ) port = int ( sys . argv [ 1 ]) app . run ( host = '0.0.0.0' , port = port ) The Dependencies \u00b6 Our App has some dependences, so we need to take care of them, here below the list of the software dependences: Click==7.0 Flask==1.1.1 itsdangerous==1.1.0 Jinja2==2.11.3 MarkupSafe==1.1.1 Werkzeug==0.16.0 Tip We will Use pip to install the requirements listed in requirements.txt : * pip install -r requirements.txt Running the server \u00b6 Of course we want our App be up&running. The server requires one command line argument: the port that it should listen on. To run the app we need just something like python app.py <PORT> Compose the Dockerfile \u00b6 Let's now build the Dockerfile in order to pack our app FROM python:3.7-slim-buster RUN apt-get update && apt-get install -y curl COPY requirements.txt /tmp/ RUN pip install -r /tmp/requirements.txt ENV PORT = \"3000\" EXPOSE ${PORT} RUN useradd --create-home pythonappuser WORKDIR /home/pythonappuser COPY startup.sh . COPY app.py . RUN chmod +x startup.sh && chmod +x app.py && chown -R pythonappuser:pythonappuser . USER pythonappuser ENTRYPOINT [ \"./startup.sh\" ] Now we can try to build it: docker build -t mycontainerizedapp . Playing with our Dockerized - App \u00b6 First of all let's check it is doing what is expected. So we should run the container and check that the Python App is actually running. So docker run -d mycontainerizedapp now we can get the ID of the container ( you know how to do that now ) and then we can get a bash in to our container: docker exec -ti 9ea45699221b bash Now if it is correctly running it should tell us something if we ask someting on its port 3000 ( remmember what we set in our Dockerfile above ) pythonappuser@9ea45699221b:~$ curl localhost:3000 { \"env\" : \"prod\" } pythonappuser@9ea45699221b:~$ here we go!! it works nicely. Very good, let's do a step further. We know that we can map the exposed port to the HOST.. so let's do it docker run -d -p 3000 :3000 mycontainerizedapp if it is all working now I shouldn't need to enter the container to check the status of the App on port 3000.. let's try curl localhost:3000 { \"env\" : \"prod\" } It works. So all is ok. Tip Remember that the EXPOSE instruction does not actually publish the port. It functions as a type of documentation between the person who builds the image and the person who runs the container, about which ports are intended to be published Final step now is about the env variable. Can we re-define it when we startup the continer ? yes we can, remember the -e docker run -d -p 3000 :3000 -e ENVIRONMENT = ciccio mycontainerizedapp If it worked correctly we should get something different wrt the previous test by querying the port 3000.. let's try: curl localhost:3000 { \"env\" : \"ciccio\" } ineed! All good! Optimize the building ( simple example ) \u00b6 Now, provided that you got the repo: git clone https://github.com/spigad/simple-exercise.git you can try to optimize a bit and use the .dockerignore file. So, you should create the file with the following content: *.md .git* and then you can check the effect of the .dockerignore by comaparing the Sending build context to Docker daemon with and without.","title":"Exercise"},{"location":"image/dockerfile/exercise/#the-app","text":"A simple python3 API that only responds at / . It returns the value of the ENVIRONMENT environment var as JSON. from flask import Flask import os import sys app = Flask ( __name__ ) @app . route ( \"/\" ) def index (): env = os . getenv ( \"ENVIRONMENT\" , None ) return { \"env\" : env } if __name__ == \"__main__\" : if len ( sys . argv ) < 2 : print ( \"Needs port number as a commandline argument.\" ) sys . exit ( 1 ) port = int ( sys . argv [ 1 ]) app . run ( host = '0.0.0.0' , port = port )","title":"The App"},{"location":"image/dockerfile/exercise/#the-dependencies","text":"Our App has some dependences, so we need to take care of them, here below the list of the software dependences: Click==7.0 Flask==1.1.1 itsdangerous==1.1.0 Jinja2==2.11.3 MarkupSafe==1.1.1 Werkzeug==0.16.0 Tip We will Use pip to install the requirements listed in requirements.txt : * pip install -r requirements.txt","title":"The  Dependencies"},{"location":"image/dockerfile/exercise/#running-the-server","text":"Of course we want our App be up&running. The server requires one command line argument: the port that it should listen on. To run the app we need just something like python app.py <PORT>","title":"Running the server"},{"location":"image/dockerfile/exercise/#compose-the-dockerfile","text":"Let's now build the Dockerfile in order to pack our app FROM python:3.7-slim-buster RUN apt-get update && apt-get install -y curl COPY requirements.txt /tmp/ RUN pip install -r /tmp/requirements.txt ENV PORT = \"3000\" EXPOSE ${PORT} RUN useradd --create-home pythonappuser WORKDIR /home/pythonappuser COPY startup.sh . COPY app.py . RUN chmod +x startup.sh && chmod +x app.py && chown -R pythonappuser:pythonappuser . USER pythonappuser ENTRYPOINT [ \"./startup.sh\" ] Now we can try to build it: docker build -t mycontainerizedapp .","title":"Compose the Dockerfile"},{"location":"image/dockerfile/exercise/#playing-with-our-dockerized-app","text":"First of all let's check it is doing what is expected. So we should run the container and check that the Python App is actually running. So docker run -d mycontainerizedapp now we can get the ID of the container ( you know how to do that now ) and then we can get a bash in to our container: docker exec -ti 9ea45699221b bash Now if it is correctly running it should tell us something if we ask someting on its port 3000 ( remmember what we set in our Dockerfile above ) pythonappuser@9ea45699221b:~$ curl localhost:3000 { \"env\" : \"prod\" } pythonappuser@9ea45699221b:~$ here we go!! it works nicely. Very good, let's do a step further. We know that we can map the exposed port to the HOST.. so let's do it docker run -d -p 3000 :3000 mycontainerizedapp if it is all working now I shouldn't need to enter the container to check the status of the App on port 3000.. let's try curl localhost:3000 { \"env\" : \"prod\" } It works. So all is ok. Tip Remember that the EXPOSE instruction does not actually publish the port. It functions as a type of documentation between the person who builds the image and the person who runs the container, about which ports are intended to be published Final step now is about the env variable. Can we re-define it when we startup the continer ? yes we can, remember the -e docker run -d -p 3000 :3000 -e ENVIRONMENT = ciccio mycontainerizedapp If it worked correctly we should get something different wrt the previous test by querying the port 3000.. let's try: curl localhost:3000 { \"env\" : \"ciccio\" } ineed! All good!","title":"Playing with our Dockerized - App"},{"location":"image/dockerfile/exercise/#optimize-the-building-simple-example","text":"Now, provided that you got the repo: git clone https://github.com/spigad/simple-exercise.git you can try to optimize a bit and use the .dockerignore file. So, you should create the file with the following content: *.md .git* and then you can check the effect of the .dockerignore by comaparing the Sending build context to Docker daemon with and without.","title":"Optimize the building ( simple example )"},{"location":"image/dockerfile/first-dockerfile/","text":"A Dockerfile is a build recipe for a Docker image. It contains a series of instructions telling Docker how an image is constructed. Our first Dockerfile \u00b6 Our Dockerfile must be in a new, empty directory so first step is to create a directory to hold our Dockerfile. Command mkdir myimage and now create a Dockerfile inside this directory. Command cd myimage vim Dockerfile (feel fre to choose any editor you like) and add the follwing content: FROM ubuntu:18.04 RUN apt-get update RUN apt-get install -y figlet Tip FROM indicates the base image for our build. Each RUN line will be executed by Docker during the build. RUN commands must be non-interactive. (No input can be provided to Docker during the build.) this is why we add the -y flag to apt-get. Every Dockerfile must start with the FROM instruction. The idea behind is that you need a starting point to build your image. You can start FROM scratch , scratch is an explicitly empty image on the Docker store that is used to build base images such as Alpine a lightweight linux distro that allows you to reduce the overall size of Docker images. Save our file, then execute: Command docker build -t myfiglet . Tip -t indicates the tag to apply to the image. . indicates the location of the build context. The output you will get is something like the follwing Sending build context to Docker daemon 2.048kB Step 1/3 : FROM ubuntu:18.04 ---> 81bcf752ac3d Step 2/3 : RUN apt-get update ---> Running in 9f07f31f5608 ...(..cut RUN output..)... Reading package lists... Removing intermediate container 9f07f31f5608 ---> e2ed94338e24 Step 3/3 : RUN apt-get install figlet ---> Running in 9548f425acac Reading package lists... ...(..cut RUN output..)... Removing intermediate container 9548f425acac ---> d9c8c229f154 Successfully built d9c8c229f154 Successfully tagged myfiglet:latest Let's analyze the oputput: Sending build context to Docker daemon 2.048 kB The build context is the . directory given to docker build. It is sent (as an archive) by the Docker client to the Docker daemon. This allows to use a remote machine to build using local files. Be careful (or patient) if that directory is big and your link is slow. You can speed up the process with a .dockerignore file which tells docker to ignore specific files in the directory, ignore files that you won't need in the build context! Step 2/3 : RUN apt-get update ---> Running in 9f07f31f5608 ...(..cut RUN output..)... Reading package lists... Removing intermediate container 9f07f31f5608 ---> e2ed94338e24 A container (9f07f31f5608) is created from the base image. The RUN command is executed in this container. The container is committed into an image (e2ed94338e24). The build container (9f07f31f5608) is removed. The output of this step will be the base image for the next one. Tip After each build step, Docker takes a snapshot of the resulting image and before executing a step, Docker checks if it has already built the same sequence. Docker uses the exact strings defined in your Dockerfile, so the following two are not the same! RUN apt-get install figlet cowsay RUN apt-get install cowsay figlet You can force a rebuild with docker build --no-cache .... And to close the loop: (only) RUN , COPY and ADD instructions create layers to improve build performance. The main advantage of image layering lies in image caching. Running the image \u00b6 The resulting image is not different from the one produced manually. :) docker run -ti myfiglet bash and issue something like: root@4d7d8ec44135:/# figlet ciao ciao _ _ ___(_) __ _ ___ ___(_) __ _ ___ / __| |/ _` |/ _ \\ / __| |/ _` |/ _ \\ | (__| | (_| | (_) | | (__| | (_| | (_) | \\___|_|\\__,_|\\___/ \\___|_|\\__,_|\\___/ root@4d7d8ec44135:/#","title":"Write the first Dockerfile"},{"location":"image/dockerfile/first-dockerfile/#our-first-dockerfile","text":"Our Dockerfile must be in a new, empty directory so first step is to create a directory to hold our Dockerfile. Command mkdir myimage and now create a Dockerfile inside this directory. Command cd myimage vim Dockerfile (feel fre to choose any editor you like) and add the follwing content: FROM ubuntu:18.04 RUN apt-get update RUN apt-get install -y figlet Tip FROM indicates the base image for our build. Each RUN line will be executed by Docker during the build. RUN commands must be non-interactive. (No input can be provided to Docker during the build.) this is why we add the -y flag to apt-get. Every Dockerfile must start with the FROM instruction. The idea behind is that you need a starting point to build your image. You can start FROM scratch , scratch is an explicitly empty image on the Docker store that is used to build base images such as Alpine a lightweight linux distro that allows you to reduce the overall size of Docker images. Save our file, then execute: Command docker build -t myfiglet . Tip -t indicates the tag to apply to the image. . indicates the location of the build context. The output you will get is something like the follwing Sending build context to Docker daemon 2.048kB Step 1/3 : FROM ubuntu:18.04 ---> 81bcf752ac3d Step 2/3 : RUN apt-get update ---> Running in 9f07f31f5608 ...(..cut RUN output..)... Reading package lists... Removing intermediate container 9f07f31f5608 ---> e2ed94338e24 Step 3/3 : RUN apt-get install figlet ---> Running in 9548f425acac Reading package lists... ...(..cut RUN output..)... Removing intermediate container 9548f425acac ---> d9c8c229f154 Successfully built d9c8c229f154 Successfully tagged myfiglet:latest Let's analyze the oputput: Sending build context to Docker daemon 2.048 kB The build context is the . directory given to docker build. It is sent (as an archive) by the Docker client to the Docker daemon. This allows to use a remote machine to build using local files. Be careful (or patient) if that directory is big and your link is slow. You can speed up the process with a .dockerignore file which tells docker to ignore specific files in the directory, ignore files that you won't need in the build context! Step 2/3 : RUN apt-get update ---> Running in 9f07f31f5608 ...(..cut RUN output..)... Reading package lists... Removing intermediate container 9f07f31f5608 ---> e2ed94338e24 A container (9f07f31f5608) is created from the base image. The RUN command is executed in this container. The container is committed into an image (e2ed94338e24). The build container (9f07f31f5608) is removed. The output of this step will be the base image for the next one. Tip After each build step, Docker takes a snapshot of the resulting image and before executing a step, Docker checks if it has already built the same sequence. Docker uses the exact strings defined in your Dockerfile, so the following two are not the same! RUN apt-get install figlet cowsay RUN apt-get install cowsay figlet You can force a rebuild with docker build --no-cache .... And to close the loop: (only) RUN , COPY and ADD instructions create layers to improve build performance. The main advantage of image layering lies in image caching.","title":"Our first Dockerfile"},{"location":"image/dockerfile/first-dockerfile/#running-the-image","text":"The resulting image is not different from the one produced manually. :) docker run -ti myfiglet bash and issue something like: root@4d7d8ec44135:/# figlet ciao ciao _ _ ___(_) __ _ ___ ___(_) __ _ ___ / __| |/ _` |/ _ \\ / __| |/ _` |/ _ \\ | (__| | (_| | (_) | | (__| | (_| | (_) | \\___|_|\\__,_|\\___/ \\___|_|\\__,_|\\___/ root@4d7d8ec44135:/#","title":"Running the image"},{"location":"image/dockerfile/instructions/","text":"We\u2019ll cover the following basic instructions to get you started: FROM - every Dockerfile starts with FROM, with the introduction of multi-stage builds, you can have more than one FROM instruction in one Dockerfile. COPY vs ADD - Add directories and files to your Docker image. ( Sometime confuesd... ) ENV - set environment variables. RUN - let\u2019s run commands. USER - when root is too mainstream. WORKDIR - set the working directory. EXPOSE - get your ports right. FROM \u00b6 Every Dockerfile must start with the FROM instruction in the form of FROM <image>[:tag] . This will set the base image for your Dockerfile, which means that subsequent instructions will be applied to this base image. The tag value is optional , if you don\u2019t specify the tag Docker will use the tag latest and will try and use or pull the latest version of the base image during build. On the little bit more advanced side, let\u2019s note the following: There is one instruction that you can put before FROM into your Dockerfile. This instruction is ARG . ARG is used to specify arguments for the docker build command with the --build-arg <varname>=<value> flag. You can have more than one FROM instructions in your Dockerfile. You will want to use this feature, for example, when you use one base image to build your app and another base image to run it. It\u2019s called a multi-stage build and you can read about it here . This is why every section that starts with FROM in your Dockerfile is called a build stage (even in the simple case of having only one FROM instruction). You can specify the name of the build stage in the form FROM <image>[:tag] [AS <name>] . COPY vs ADD \u00b6 Both ADD and COPY are designed to add directories and files to your Docker image in the form of ADD <src>... <dest> or COPY <src>... <dest> . Most resources, suggest to use COPY . The reason behind this is that ADD has extra features compared to COPY that make ADD more unpredictable and a bit over-designed. ADD can pull files from url sources, which COPY cannot. ADD can also extract compressed files assuming it can recognize and handle the format. You cannot extract archives with COPY. The ADD instruction was added to Docker first, and COPY was added later to provide a straightforward, rock solid solution for copying files and directories into your container\u2019s file system. If you want to pull files from the web into your image I would suggest to use RUN and curl and uncompress your files with RUN and commands you would use on the command line. ENV \u00b6 ENV is used to define environment variables. The interesting thing about ENV is that it does two things: You can use it to define environment variables that will be available in your container. So when you build an image and start up a container with that image you\u2019ll find that the environment variable is available and is set to the value you specified in the Dockerfile. You can use the variables that you specify by ENV in the Dockerfile itself. So in subsequent instructions the environment variable will be available. RUN \u00b6 RUN will execute commands, so it\u2019s one of the most-used instructions. I would like to highlight two points: You\u2019ll use a lot of apt-get type of commands to add new packages to your image. It\u2019s always advisable to put apt-get update and apt-get install commands on the same line . This is important because of layer caching. Having these on two separate lines would mean that if you add a new package to your install list, the layer with apt-get update will not be invalidated in the layer cache and you might end up in a mess. Read more here. RUN has two forms; RUN <command> (called shell form) and RUN [\"executable\", \"param1\", \"param2\"] called exec form. Please note that RUN <command> will invoke a shell automatically (/bin/sh -c by default), while the exec form will not invoke a command shell. USER \u00b6 Don\u2019t run your stuff as root, use the USER instruction to specify the user. This user will be used to run any subsequent RUN, CMD AND ENDPOINT instructions in your Dockerfile. WORKDIR \u00b6 A very convenient way to define the working directory, it will be used with subsequent RUN, CMD, ENTRYPOINT, COPY and ADD instructions. You can specify WORKDIR multiple times in a Dockerfile. If the directory does not exists, Docker will create it for you. EXPOSE \u00b6 An important instruction to inform your users about the ports your application is listening on. EXPOSE will not publish the port , you need to use docker run -p... to do that when you start the container. CMD and ENTRYPOINT \u00b6 CMD is the instruction to specify what component is to be run by your image with arguments in the following form: CMD [\u201cexecutable\u201d, \u201cparam1\u201d, \u201cparam2\u201d\u2026]. You can override CMD when you\u2019re starting up your container by specifying your command after the image name like this: $ docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...] . You can only specify one CMD in a Dockerfile (OK, physically you can specify more than one, but only the last one will be used). So what\u2019s the deal with ENTRYPOINT? When you specify an entry point, your image will work a bit differently. You use ENTRYPOINT as the main executable of your image . In this case whatever you specify in CMD will be added to ENTRYPOINT as parameters.","title":"Overview of basic instructions"},{"location":"image/dockerfile/instructions/#from","text":"Every Dockerfile must start with the FROM instruction in the form of FROM <image>[:tag] . This will set the base image for your Dockerfile, which means that subsequent instructions will be applied to this base image. The tag value is optional , if you don\u2019t specify the tag Docker will use the tag latest and will try and use or pull the latest version of the base image during build. On the little bit more advanced side, let\u2019s note the following: There is one instruction that you can put before FROM into your Dockerfile. This instruction is ARG . ARG is used to specify arguments for the docker build command with the --build-arg <varname>=<value> flag. You can have more than one FROM instructions in your Dockerfile. You will want to use this feature, for example, when you use one base image to build your app and another base image to run it. It\u2019s called a multi-stage build and you can read about it here . This is why every section that starts with FROM in your Dockerfile is called a build stage (even in the simple case of having only one FROM instruction). You can specify the name of the build stage in the form FROM <image>[:tag] [AS <name>] .","title":"FROM"},{"location":"image/dockerfile/instructions/#copy-vs-add","text":"Both ADD and COPY are designed to add directories and files to your Docker image in the form of ADD <src>... <dest> or COPY <src>... <dest> . Most resources, suggest to use COPY . The reason behind this is that ADD has extra features compared to COPY that make ADD more unpredictable and a bit over-designed. ADD can pull files from url sources, which COPY cannot. ADD can also extract compressed files assuming it can recognize and handle the format. You cannot extract archives with COPY. The ADD instruction was added to Docker first, and COPY was added later to provide a straightforward, rock solid solution for copying files and directories into your container\u2019s file system. If you want to pull files from the web into your image I would suggest to use RUN and curl and uncompress your files with RUN and commands you would use on the command line.","title":"COPY vs ADD"},{"location":"image/dockerfile/instructions/#env","text":"ENV is used to define environment variables. The interesting thing about ENV is that it does two things: You can use it to define environment variables that will be available in your container. So when you build an image and start up a container with that image you\u2019ll find that the environment variable is available and is set to the value you specified in the Dockerfile. You can use the variables that you specify by ENV in the Dockerfile itself. So in subsequent instructions the environment variable will be available.","title":"ENV"},{"location":"image/dockerfile/instructions/#run","text":"RUN will execute commands, so it\u2019s one of the most-used instructions. I would like to highlight two points: You\u2019ll use a lot of apt-get type of commands to add new packages to your image. It\u2019s always advisable to put apt-get update and apt-get install commands on the same line . This is important because of layer caching. Having these on two separate lines would mean that if you add a new package to your install list, the layer with apt-get update will not be invalidated in the layer cache and you might end up in a mess. Read more here. RUN has two forms; RUN <command> (called shell form) and RUN [\"executable\", \"param1\", \"param2\"] called exec form. Please note that RUN <command> will invoke a shell automatically (/bin/sh -c by default), while the exec form will not invoke a command shell.","title":"RUN"},{"location":"image/dockerfile/instructions/#user","text":"Don\u2019t run your stuff as root, use the USER instruction to specify the user. This user will be used to run any subsequent RUN, CMD AND ENDPOINT instructions in your Dockerfile.","title":"USER"},{"location":"image/dockerfile/instructions/#workdir","text":"A very convenient way to define the working directory, it will be used with subsequent RUN, CMD, ENTRYPOINT, COPY and ADD instructions. You can specify WORKDIR multiple times in a Dockerfile. If the directory does not exists, Docker will create it for you.","title":"WORKDIR"},{"location":"image/dockerfile/instructions/#expose","text":"An important instruction to inform your users about the ports your application is listening on. EXPOSE will not publish the port , you need to use docker run -p... to do that when you start the container.","title":"EXPOSE"},{"location":"image/dockerfile/instructions/#cmd-and-entrypoint","text":"CMD is the instruction to specify what component is to be run by your image with arguments in the following form: CMD [\u201cexecutable\u201d, \u201cparam1\u201d, \u201cparam2\u201d\u2026]. You can override CMD when you\u2019re starting up your container by specifying your command after the image name like this: $ docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...] . You can only specify one CMD in a Dockerfile (OK, physically you can specify more than one, but only the last one will be used). So what\u2019s the deal with ENTRYPOINT? When you specify an entry point, your image will work a bit differently. You use ENTRYPOINT as the main executable of your image . In this case whatever you specify in CMD will be added to ENTRYPOINT as parameters.","title":"CMD and ENTRYPOINT"},{"location":"image/intro/","text":"This is a quick recap of things that you already saw in the Part-1. The following steps guide you toward the interactive image building process. Getting an image and apply some changes \u00b6 Command docker run -it ubuntu:18.04 You will get something like the following output: Unable to find image 'ubuntu:18.04' locally 18.04: Pulling from library/ubuntu 4bbfd2c87b75: Pull complete d2e110be24e1: Pull complete 889a7173dcfe: Pull complete Digest: sha256:67b730ece0d34429b455c08124ffd444f021b81e06fa2d9cd0adaf0d0b875182 Status: Downloaded newer image for ubuntu:18.04 root@844ec9e540a5:/# Run the command apt-get update to refresh the list of packages available to install. For this simple exercise we will use Figlet Then run the command apt-get install figlet to install the program we are interested in. Command apt-get update && apt-get install figlet You will get something like the following output: root@844ec9e540a5:/# apt-get update && apt-get install figlet Get:1 http://archive.ubuntu.com/ubuntu bionic InRelease [242 kB] Get:2 http://archive.ubuntu.com/ubuntu bionic-updates InRelease [88.7 kB] Get:3 http://security.ubuntu.com/ubuntu bionic-security InRelease [88.7 kB] Get:4 http://archive.ubuntu.com/ubuntu bionic-backports InRelease [74.6 kB] Get:5 http://archive.ubuntu.com/ubuntu bionic/main amd64 Packages [1344 kB] Get:6 http://archive.ubuntu.com/ubuntu bionic/restricted amd64 Packages [13.5 kB] Get:7 http://archive.ubuntu.com/ubuntu bionic/multiverse amd64 Packages [186 kB] Get:8 http://archive.ubuntu.com/ubuntu bionic/universe amd64 Packages [11.3 MB] Get:9 http://archive.ubuntu.com/ubuntu bionic-updates/multiverse amd64 Packages [33.5 kB] Get:10 http://archive.ubuntu.com/ubuntu bionic-updates/restricted amd64 Packages [481 kB] Get:11 http://archive.ubuntu.com/ubuntu bionic-updates/main amd64 Packages [2619 kB] Get:12 http://archive.ubuntu.com/ubuntu bionic-updates/universe amd64 Packages [2185 kB] Get:13 http://archive.ubuntu.com/ubuntu bionic-backports/universe amd64 Packages [11.4 kB] Get:14 http://archive.ubuntu.com/ubuntu bionic-backports/main amd64 Packages [11.3 kB] Get:15 http://security.ubuntu.com/ubuntu bionic-security/universe amd64 Packages [1415 kB] ... ... Check the differences with respect to the original image \u00b6 Once done type exit at the container prompt to leave the interactive session. Now let's run docker diff to see the difference between the base image and our container. Command docker diff 844ec9e540a5 Tip Remember: you need to use your container ID. In order to get it you can always use docker ps -a and the output you will get is something like C /root A /root/.bash_history C /etc A /etc/emacs A /etc/emacs/site-start.d A /etc/emacs/site-start.d/50figlet.el C /etc/alternatives A /etc/alternatives/figlet C /usr C /usr/share A /usr/share/figlet A /usr/share/figlet/646-ca.flc A /usr/share/figlet/646-ca2.flc A /usr/share/figlet/646-hu.flc Tip Three different types of change are tracked by docker diff : - A A file or directory was added - D A file or directory was deleted - C A file or directory was changed Commit the changes and use your image \u00b6 The last step is now to commit the changes, that way we will create a new layer with the changes we made before, and a new image using this new layer. Command docker commit 844ec9e540a5 interactivefiglet Here we go! we have build our first image interactively! Let's run it and test it Command docker run -ti interactivefiglet once you entered the container you can type something like the following: Command figlet ciao ciao you will get your expected output: _ _ ___(_) __ _ ___ ___(_) __ _ ___ / __| |/ _` |/ _ \\ / __| |/ _` |/ _ \\ | (__| | (_| | (_) | | (__| | (_| | (_) | \\___|_|\\__,_|\\___/ \\___|_|\\__,_|\\___/ root@be9e5e08db21:/# This is ok for quick & dirty test and playground .. but what about if we need to be reproducible, automated ? To this end we need to learn the build process by writing a Dockerfile.","title":"Building interactively"},{"location":"image/intro/#getting-an-image-and-apply-some-changes","text":"Command docker run -it ubuntu:18.04 You will get something like the following output: Unable to find image 'ubuntu:18.04' locally 18.04: Pulling from library/ubuntu 4bbfd2c87b75: Pull complete d2e110be24e1: Pull complete 889a7173dcfe: Pull complete Digest: sha256:67b730ece0d34429b455c08124ffd444f021b81e06fa2d9cd0adaf0d0b875182 Status: Downloaded newer image for ubuntu:18.04 root@844ec9e540a5:/# Run the command apt-get update to refresh the list of packages available to install. For this simple exercise we will use Figlet Then run the command apt-get install figlet to install the program we are interested in. Command apt-get update && apt-get install figlet You will get something like the following output: root@844ec9e540a5:/# apt-get update && apt-get install figlet Get:1 http://archive.ubuntu.com/ubuntu bionic InRelease [242 kB] Get:2 http://archive.ubuntu.com/ubuntu bionic-updates InRelease [88.7 kB] Get:3 http://security.ubuntu.com/ubuntu bionic-security InRelease [88.7 kB] Get:4 http://archive.ubuntu.com/ubuntu bionic-backports InRelease [74.6 kB] Get:5 http://archive.ubuntu.com/ubuntu bionic/main amd64 Packages [1344 kB] Get:6 http://archive.ubuntu.com/ubuntu bionic/restricted amd64 Packages [13.5 kB] Get:7 http://archive.ubuntu.com/ubuntu bionic/multiverse amd64 Packages [186 kB] Get:8 http://archive.ubuntu.com/ubuntu bionic/universe amd64 Packages [11.3 MB] Get:9 http://archive.ubuntu.com/ubuntu bionic-updates/multiverse amd64 Packages [33.5 kB] Get:10 http://archive.ubuntu.com/ubuntu bionic-updates/restricted amd64 Packages [481 kB] Get:11 http://archive.ubuntu.com/ubuntu bionic-updates/main amd64 Packages [2619 kB] Get:12 http://archive.ubuntu.com/ubuntu bionic-updates/universe amd64 Packages [2185 kB] Get:13 http://archive.ubuntu.com/ubuntu bionic-backports/universe amd64 Packages [11.4 kB] Get:14 http://archive.ubuntu.com/ubuntu bionic-backports/main amd64 Packages [11.3 kB] Get:15 http://security.ubuntu.com/ubuntu bionic-security/universe amd64 Packages [1415 kB] ... ...","title":"Getting an image and apply some changes"},{"location":"image/intro/#check-the-differences-with-respect-to-the-original-image","text":"Once done type exit at the container prompt to leave the interactive session. Now let's run docker diff to see the difference between the base image and our container. Command docker diff 844ec9e540a5 Tip Remember: you need to use your container ID. In order to get it you can always use docker ps -a and the output you will get is something like C /root A /root/.bash_history C /etc A /etc/emacs A /etc/emacs/site-start.d A /etc/emacs/site-start.d/50figlet.el C /etc/alternatives A /etc/alternatives/figlet C /usr C /usr/share A /usr/share/figlet A /usr/share/figlet/646-ca.flc A /usr/share/figlet/646-ca2.flc A /usr/share/figlet/646-hu.flc Tip Three different types of change are tracked by docker diff : - A A file or directory was added - D A file or directory was deleted - C A file or directory was changed","title":"Check the differences with respect to the original image"},{"location":"image/intro/#commit-the-changes-and-use-your-image","text":"The last step is now to commit the changes, that way we will create a new layer with the changes we made before, and a new image using this new layer. Command docker commit 844ec9e540a5 interactivefiglet Here we go! we have build our first image interactively! Let's run it and test it Command docker run -ti interactivefiglet once you entered the container you can type something like the following: Command figlet ciao ciao you will get your expected output: _ _ ___(_) __ _ ___ ___(_) __ _ ___ / __| |/ _` |/ _ \\ / __| |/ _` |/ _ \\ | (__| | (_| | (_) | | (__| | (_| | (_) | \\___|_|\\__,_|\\___/ \\___|_|\\__,_|\\___/ root@be9e5e08db21:/# This is ok for quick & dirty test and playground .. but what about if we need to be reproducible, automated ? To this end we need to learn the build process by writing a Dockerfile.","title":"Commit the changes and use your image"},{"location":"image/multistage/multistage-example/","text":"The objective here is to try to use multi-stage images in practice. To this end we will change our Dockerfile to: give a nickname to the first stage: compiler add a second stage using the same ubuntu base image add the hello binary to the second stage make sure that CMD is in the second stage Mulit-stage Docker file: example \u00b6 Here is the final Dockerfile: FROM ubuntu AS compiler RUN apt-get update RUN apt-get install -y build-essential COPY hello.c / RUN make hello FROM ubuntu COPY --from = compiler /hello /hello CMD /hello Let's build it, and check that it works correctly: docker build -t hellomultistage . and now we can test: docker run hellomultistage Home work \u00b6 List our images with docker images, and check the size of: The ubuntu base image, The single-stage hello image, The multi-stage hellomultistage image. We can achieve even smaller images if we use smaller base images ( i.e. Apline etc )","title":"Our first multi-stage Dockerfile"},{"location":"image/multistage/multistage-example/#mulit-stage-docker-file-example","text":"Here is the final Dockerfile: FROM ubuntu AS compiler RUN apt-get update RUN apt-get install -y build-essential COPY hello.c / RUN make hello FROM ubuntu COPY --from = compiler /hello /hello CMD /hello Let's build it, and check that it works correctly: docker build -t hellomultistage . and now we can test: docker run hellomultistage","title":"Mulit-stage Docker file: example"},{"location":"image/multistage/multistage-example/#home-work","text":"List our images with docker images, and check the size of: The ubuntu base image, The single-stage hello image, The multi-stage hellomultistage image. We can achieve even smaller images if we use smaller base images ( i.e. Apline etc )","title":"Home work"},{"location":"image/registry/dockerhub/","text":"Now that we have built our first images, we can publish them to the Docker Hub! Logging into our Docker Hub account \u00b6 docker login This requires an account on the Docker Hub ( which is free as well as storing the images it is free ). So if you have one you can try a thus you'll see a output like this: Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one. Username: spiga Password: WARNING! Your password will be stored unencrypted in /home/tutor5/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded Tagging an image to push it on the Hub \u00b6 Docker images tags are like Git tags and branches, like bookmarks pointing at a specific image ID. Tagging an image doesn't rename an image: it adds another tag. When pushing an image to a registry, the registry address is in the tag. Example: registry.example.net:5000/image spiga/test is index.docker.io/spiga/test ubuntu is index.docker.io/library/ubuntu Let's tag our myfiglet image \u00b6 Or please do it with any other image you like. Let's look for the image to tag: $docker images REPOSITORY TAG IMAGE ID CREATED SIZE myfiglet latest cabcb70593be 15 seconds ago 103MB mycontainerizedapp latest b64faab26e8f 30 hours ago 147MB python 3.7-slim-buster 867339bd5033 2 weeks ago 113MB ubuntu 18.04 81bcf752ac3d 3 weeks ago 63.1MB gcr.io/k8s-minikube/kicbase v0.0.22 bcd131522525 5 weeks ago 1.09GB ubuntu latest 7e0aa2d69a15 7 weeks ago 72.7MB Ok let's tag the myfiglet docker tag myfiglet spiga/myfiglet and check what's happening now: docker images REPOSITORY TAG IMAGE ID CREATED SIZE myfiglet latest cabcb70593be About a minute ago 103MB spiga/myfiglet latest cabcb70593be About a minute ago 103MB mycontainerizedapp latest b64faab26e8f 30 hours ago 147MB python 3.7-slim-buster 867339bd5033 2 weeks ago 113MB ubuntu 18.04 81bcf752ac3d 3 weeks ago 63.1MB gcr.io/k8s-minikube/kicbase v0.0.22 bcd131522525 5 weeks ago 1.09GB ubuntu latest 7e0aa2d69a15 7 weeks ago 72.7MB Ok so we are ready to push it on Dockerhub docker push spiga/myfiglet and the output will look like something this one Using default tag: latest The push refers to repository [docker.io/spiga/myfiglet] f0f9028d0afb: Pushed 3ee587de5e03: Pushed 2f140462f3bc: Mounted from library/ubuntu 63c99163f472: Mounted from library/ubuntu ccdbb80308cc: Mounted from library/ubuntu latest: digest: sha256:ec988085cd4d5efa6bdb5b26a3694eff2c6e26032521c4b6cb248b4efb0f5f51 size: 1365 Ok, very good! That's it! Anybody can now docker run spiga/myfiglet anywhere . Quick check \u00b6 Now if we remove the image on local filesystem and the we get it back from the registry ( DockerHub ) we can see how it works and we close the loop. Tip To remove the image : docker rmi IMAGE ID . To get the IMAGE ID just use docker images docker pull spiga/myfiglet Using default tag: latest latest: Pulling from spiga/myfiglet 345e3491a907: Already exists 57671312ef6f: Already exists 5e9250ddb7d0: Already exists d9dac9d5417f: Pull complete bdf8f857644c: Pull complete Digest: sha256:ec988085cd4d5efa6bdb5b26a3694eff2c6e26032521c4b6cb248b4efb0f5f51 Status: Downloaded newer image for spiga/myfiglet:latest docker.io/spiga/myfiglet:latest","title":"Publishing images to the Docker hub"},{"location":"image/registry/dockerhub/#logging-into-our-docker-hub-account","text":"docker login This requires an account on the Docker Hub ( which is free as well as storing the images it is free ). So if you have one you can try a thus you'll see a output like this: Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one. Username: spiga Password: WARNING! Your password will be stored unencrypted in /home/tutor5/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded","title":"Logging into our Docker Hub account"},{"location":"image/registry/dockerhub/#tagging-an-image-to-push-it-on-the-hub","text":"Docker images tags are like Git tags and branches, like bookmarks pointing at a specific image ID. Tagging an image doesn't rename an image: it adds another tag. When pushing an image to a registry, the registry address is in the tag. Example: registry.example.net:5000/image spiga/test is index.docker.io/spiga/test ubuntu is index.docker.io/library/ubuntu","title":"Tagging an image to push it on the Hub"},{"location":"image/registry/dockerhub/#lets-tag-our-myfiglet-image","text":"Or please do it with any other image you like. Let's look for the image to tag: $docker images REPOSITORY TAG IMAGE ID CREATED SIZE myfiglet latest cabcb70593be 15 seconds ago 103MB mycontainerizedapp latest b64faab26e8f 30 hours ago 147MB python 3.7-slim-buster 867339bd5033 2 weeks ago 113MB ubuntu 18.04 81bcf752ac3d 3 weeks ago 63.1MB gcr.io/k8s-minikube/kicbase v0.0.22 bcd131522525 5 weeks ago 1.09GB ubuntu latest 7e0aa2d69a15 7 weeks ago 72.7MB Ok let's tag the myfiglet docker tag myfiglet spiga/myfiglet and check what's happening now: docker images REPOSITORY TAG IMAGE ID CREATED SIZE myfiglet latest cabcb70593be About a minute ago 103MB spiga/myfiglet latest cabcb70593be About a minute ago 103MB mycontainerizedapp latest b64faab26e8f 30 hours ago 147MB python 3.7-slim-buster 867339bd5033 2 weeks ago 113MB ubuntu 18.04 81bcf752ac3d 3 weeks ago 63.1MB gcr.io/k8s-minikube/kicbase v0.0.22 bcd131522525 5 weeks ago 1.09GB ubuntu latest 7e0aa2d69a15 7 weeks ago 72.7MB Ok so we are ready to push it on Dockerhub docker push spiga/myfiglet and the output will look like something this one Using default tag: latest The push refers to repository [docker.io/spiga/myfiglet] f0f9028d0afb: Pushed 3ee587de5e03: Pushed 2f140462f3bc: Mounted from library/ubuntu 63c99163f472: Mounted from library/ubuntu ccdbb80308cc: Mounted from library/ubuntu latest: digest: sha256:ec988085cd4d5efa6bdb5b26a3694eff2c6e26032521c4b6cb248b4efb0f5f51 size: 1365 Ok, very good! That's it! Anybody can now docker run spiga/myfiglet anywhere .","title":"Let's tag our myfiglet image"},{"location":"image/registry/dockerhub/#quick-check","text":"Now if we remove the image on local filesystem and the we get it back from the registry ( DockerHub ) we can see how it works and we close the loop. Tip To remove the image : docker rmi IMAGE ID . To get the IMAGE ID just use docker images docker pull spiga/myfiglet Using default tag: latest latest: Pulling from spiga/myfiglet 345e3491a907: Already exists 57671312ef6f: Already exists 5e9250ddb7d0: Already exists d9dac9d5417f: Pull complete bdf8f857644c: Pull complete Digest: sha256:ec988085cd4d5efa6bdb5b26a3694eff2c6e26032521c4b6cb248b4efb0f5f51 Status: Downloaded newer image for spiga/myfiglet:latest docker.io/spiga/myfiglet:latest","title":"Quick check"},{"location":"intro/container/","text":"Source: https://twitter.com/pierrecdn/status/620587662928424960 docker create command will create a new Docker container with the specified docker image. docker create --name <container name> <image name> docker start command can be used to start a stopped container. docker start <container name> docker run command does the work of both docker create and docker start command. docker run -it --name <container name> <image name> docker pause command can be used to pause the processes running inside the container (a SIGSTOP signal will be sent to the main process). docker pause <container name> docker unpause command allows to unpause the container. docker unpause <container name> docker stop command can be used to stop all the processes running in the container: the main process inside the container receives a SIGTERM signal. docker stop <container name> docker rm command is used to destroy a stopped container (with --force option you can destroy a running container, but it's better to stop it before) docker rm <container name> docker kill command will kill all the processes in the container: the main process will be sent a SIGKILL or any signal specified with option \u2013signal . docker kill <container name> Docker command syntax \u00b6 Prior to version 1.13, Docker had only the previously mentioned command syntax. Later on, the command-line was restructured to have the following syntax: docker <object> <command> <options> In this syntax: object indicates the type of Docker object you'll be manipulating. This can be a container, image, network or volume object. command indicates the task to be carried out by the daemon, that is the run command. options can be any valid parameter that can override the default behavior of the command, like the --publish option for port mapping. The commands in the previous sections can be re-written as docker container <command> , e.g. docker container create or docker container run . To learn more about the available commands, visit the official documentation .","title":"Docker container lifecycle"},{"location":"intro/container/#docker-command-syntax","text":"Prior to version 1.13, Docker had only the previously mentioned command syntax. Later on, the command-line was restructured to have the following syntax: docker <object> <command> <options> In this syntax: object indicates the type of Docker object you'll be manipulating. This can be a container, image, network or volume object. command indicates the task to be carried out by the daemon, that is the run command. options can be any valid parameter that can override the default behavior of the command, like the --publish option for port mapping. The commands in the previous sections can be re-written as docker container <command> , e.g. docker container create or docker container run . To learn more about the available commands, visit the official documentation .","title":"Docker command syntax"},{"location":"intro/hello-world/","text":"Let's create our first docker container: Command docker container run hello-world Look at the output: Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world b8dfde127a29: Pull complete Digest: sha256:5122f6204b6a3596e048758cabba3c46b1c937a46b5be6225b835d091b90e46c Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1 . The Docker client contacted the Docker daemon. 2 . The Docker daemon pulled the \"hello-world\" image from the Docker Hub. ( amd64 ) 3 . The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4 . The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ Let's see what happened behind the scene... You launched the command docker run hello-world where hello-world is the name of a docker image. The Docker client reached out to the daemon, telling it to get the hello-world image and run a container from that. The Docker daemon looked for the image within your local repository and realized that it's not there: Unable to find image 'hello-world:latest' locally . The daemon then contacted the default public registry which is Docker Hub and pulled in the latest copy of the hello-world image: Pulling from library/hello-world . The Docker daemon then created a new container from the freshly pulled image. Finally the Docker daemon ran the container created using the hello-world image. Hello World only function is to output the text you see in the terminal, after which the container exits. You can use the command docker container ps to list the running containers (use -a option to list all the stopped containers): docker container ps -a You will find the container just started and run from the hello-world image: CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES c0ba7d45168a hello-world \"/hello\" About a minute ago Exited ( 0 ) About a minute ago thirsty_poitras Note When we create a container, if we don't give a specific name, Docker will pick one for us. It will be the concatenation of: A mood (furious, goofy, suspicious, boring...) The name of a famous inventor (tesla, darwin, wozniak...) Examples: happy_curie , jovial_lovelace ...","title":"Run your first container"},{"location":"intro/images/","text":"The storage location of Docker images and containers depends on the operating system. The command docker info provides information about your Docker configuration, including the Storage Driver and the Docker Root Dir . On Ubuntu, Docker stores images and containers files under /var/lib/docker : sudo ls /var/lib/docker/ -latr total 60 drwxr-xr-x 40 root root 4096 May 27 13 :27 .. drwx------ 3 root root 4096 May 27 13 :27 image drwx------ 2 root root 4096 May 27 13 :27 trust drwxr-x--- 3 root root 4096 May 27 13 :27 network drwx------ 2 root root 4096 May 27 13 :27 swarm drwx--x--x 4 root root 4096 May 27 13 :27 buildkit drwx------ 2 root root 4096 May 27 13 :27 runtimes drwx--x--x 13 root root 4096 May 27 13 :27 . drwx-----x 3 root root 4096 May 27 18 :23 volumes drwx------ 4 root root 4096 Jun 2 15 :50 plugins drwx------ 2 root root 4096 Jun 3 10 :58 tmp drwx-----x 6 root root 12288 Jun 3 10 :58 overlay2 drwx-----x 3 root root 4096 Jun 3 10 :58 containers Docker images are stored in /var/lib/docker/overlay2 . Let's explore the content of our image hello-world : Info The command docker inspect returns low-level information on Docker objects (images, containers, networks, etc.). More info in the Docker official doc . docker image inspect hello-world [ { \"Id\" : \"sha256:d1165f2212346b2bab48cb01c1e39ee8ad1be46b87873d9ca7a4e434980a7726\" , \"RepoTags\" : [ \"hello-world:latest\" ] , .... \"GraphDriver\" : { \"Data\" : { \"MergedDir\" : \"/var/lib/docker/overlay2/f9457322a6bf658b38d3faf3bdd607f6873b89e3be2e9de222c9eb81a069f29d/merged\" , \"UpperDir\" : \"/var/lib/docker/overlay2/f9457322a6bf658b38d3faf3bdd607f6873b89e3be2e9de222c9eb81a069f29d/diff\" , \"WorkDir\" : \"/var/lib/docker/overlay2/f9457322a6bf658b38d3faf3bdd607f6873b89e3be2e9de222c9eb81a069f29d/work\" } , \"Name\" : \"overlay2\" } , .... The GraphDriver.Data dictionary contains information about the layers of the image. In general, the LowerDir contains the read-only layers of an image. The read-write layer that represents changes are part of the UpperDir . The hello-world image is built starting from the base image scratch that is an explicitly empty image. The hello-world image therefore contains just one layer that adds the hello executable (statically linked) to the base empty image. Look at the content of the UpperDir : sudo ls -latr /var/lib/docker/overlay2/f9457322a6bf658b38d3faf3bdd607f6873b89e3be2e9de222c9eb81a069f29d/diff total 24 -rwxrwxr-x 1 root root 13336 Mar 5 23 :25 hello drwxr-xr-x 2 root root 4096 Jun 3 14 :39 . drwx-----x 3 root root 4096 Jun 3 14 :39 .. Another interesting command is docker history that shows the hystory of an image. Try it! docker history hello-world Output: IMAGE CREATED CREATED BY SIZE COMMENT d1165f221234 2 months ago /bin/sh -c #(nop) CMD [\"/hello\"] 0B <missing> 2 months ago /bin/sh -c #(nop) COPY file:7bf12aab75c3867a\u2026 13.3kB Again, you can see here that the image has only one layer (0B lines are neglected).","title":"Where are Docker images stored?"},{"location":"intro/info/","text":"You can get the basic information about your Docker configuration by executing: Command docker info You will get something like the following output: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 Client: Context: default Debug Mode: false Plugins: app: Docker App ( Docker Inc., v0.9.1-beta3 ) buildx: Docker Buildx ( Docker Inc., v0.8.2-docker ) compose: Docker Compose ( Docker Inc., v2.6.0 ) scan: Docker Scan ( Docker Inc., v0.17.0 ) Server: Containers: 0 Running: 0 Paused: 0 Stopped: 0 Images: 0 Server Version: 20 .10.17 Storage Driver: overlay2 Backing Filesystem: extfs Supports d_type: true Native Overlay Diff: true userxattr: false Logging Driver: json-file Cgroup Driver: cgroupfs Cgroup Version: 1 Plugins: Volume: local Network: bridge host ipvlan macvlan null overlay Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog Swarm: inactive Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc Default Runtime: runc Init Binary: docker-init containerd version: 0197261a30bf81f1ee8e6a4dd2dea0ef95d67ccb runc version: v1.1.3-0-g6724737 init version: de40ad0 Security Options: apparmor seccomp Profile: default Kernel Version: 5 .4.0-122-generic Operating System: Ubuntu 20 .04.4 LTS OSType: linux Architecture: x86_64 CPUs: 1 Total Memory: 1 .937GiB Name: tutorvm-1 ID: Y3GV:AHBF:EWXJ:32WB:6ADM:HGJW:XS5X:AH7N:XAVB:35JP:2T4P:KQ4M Docker Root Dir: /var/lib/docker Debug Mode: false Registry: https://index.docker.io/v1/ Labels: Experimental: false Insecure Registries: 127 .0.0.0/8 Live Restore Enabled: false WARNING: No swap limit support The output contains information about your storage driver, your docker root directory, the supported plugins (volume, network, log), the default registry, etc.","title":"Docker info"},{"location":"intro/install/","text":"We will install docker engine on our Ubuntu 20.05 (focal) Virtual Machine using the repository. Info Full instructions are available at https://docs.docker.com/engine/install/ Setup the repository \u00b6 Update the apt package index and install packages to allow apt to use a repository over HTTPS: sudo apt-get update sudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release Add Docker\u2019s official GPG key: sudo mkdir -p /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg Use the following command to set up the repository: echo \\ \"deb [arch= $( dpkg --print-architecture ) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\ $( lsb_release -cs ) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null Install Docker Engine \u00b6 Update the apt package index, and install the latest version of Docker Engine, containerd, and Docker Compose, or go to the next step to install a specific version: sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin Post-installation steps \u00b6 The Docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user root and other users can only access it using sudo . The Docker daemon always runs as the root user. If you don\u2019t want to preface the docker command with sudo , add users to the Unix group docker . When the Docker daemon starts, it creates a Unix socket accessible by members of the docker group. Add your user to the docker group. sudo usermod -aG docker $USER Log out and log back in so that your group membership is re-evaluated. Verify \u00b6 Command Example output docker --version Docker version 20.10.17, build 100c701","title":"Install docker engine on Ubuntu"},{"location":"intro/install/#setup-the-repository","text":"Update the apt package index and install packages to allow apt to use a repository over HTTPS: sudo apt-get update sudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release Add Docker\u2019s official GPG key: sudo mkdir -p /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg Use the following command to set up the repository: echo \\ \"deb [arch= $( dpkg --print-architecture ) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\ $( lsb_release -cs ) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null","title":"Setup the repository"},{"location":"intro/install/#install-docker-engine","text":"Update the apt package index, and install the latest version of Docker Engine, containerd, and Docker Compose, or go to the next step to install a specific version: sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin","title":"Install Docker Engine"},{"location":"intro/install/#post-installation-steps","text":"The Docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user root and other users can only access it using sudo . The Docker daemon always runs as the root user. If you don\u2019t want to preface the docker command with sudo , add users to the Unix group docker . When the Docker daemon starts, it creates a Unix socket accessible by members of the docker group. Add your user to the docker group. sudo usermod -aG docker $USER Log out and log back in so that your group membership is re-evaluated.","title":"Post-installation steps"},{"location":"intro/install/#verify","text":"Command Example output docker --version Docker version 20.10.17, build 100c701","title":"Verify"},{"location":"networking/networking/","text":"Let's start from a new nginx docker container: ` docker container run -d --name nginx nginx ` The inspect command provided details about the networking configuration of the container: ... \"Networks\" : { \"bridge\" : { \"IPAMConfig\" : null, \"Links\" : null, \"Aliases\" : null, \"NetworkID\" : \"0aa786b7de5fbfcd3e18db78511ed544d450bb0ad198cab0244bc8b83d30b514\" , \"EndpointID\" : \"c3b64e072f7851e3bf55ba3685fa1fbdec6b9c59d18ae27e5e90a1be5728f54c\" , \"Gateway\" : \"172.17.0.1\" , \"IPAddress\" : \"172.17.0.2\" , \"IPPrefixLen\" : 16 , \"IPv6Gateway\" : \"\" , \"GlobalIPv6Address\" : \"\" , \"GlobalIPv6PrefixLen\" : 0 , \"MacAddress\" : \"02:42:ac:11:00:02\" , \"DriverOpts\" : null } } ... To list out the networks in your system, execute the following command: Command Output docker network ls NETWORK ID NAME DRIVER SCOPE 0aa786b7de5f bridge bridge local 19747c3d0c9a host host local 36dc4ef5b900 none null local As you can see, our container is attached to the default bridge network 0aa786b7de5f (long ID: 0aa786b7de5fbfcd3e18db78511ed544d450bb0ad198cab0244bc8b83d30b514). We get more details about this network with the inspect command: Command Output docker network inspect 0aa786b7de5f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 [ { \"Name\" : \"bridge\" , \"Id\" : \"0aa786b7de5fbfcd3e18db78511ed544d450bb0ad198cab0 244bc8b83d30b514\" , \"Created\" : \"2021-05-27T13:27:32.164161898Z\" , \"Scope\" : \"local\" , \"Driver\" : \"bridge\" , \"EnableIPv6\" : false, \"IPAM\" : { \"Driver\" : \"default\" , \"Options\" : null, \"Config\" : [ { \"Subnet\" : \"172.17.0.0/16\" , \"Gateway\" : \"172.17.0.1\" } ] } , \"Internal\" : false, \"Attachable\" : false, \"Ingress\" : false, \"ConfigFrom\" : { \"Network\" : \"\" } , \"ConfigOnly\" : false, \"Containers\" : { \"2f03f1f2cd100ec584349124a93f180fa743d1c3ab7b cc31c9d8156225d6f06a\" : { \"Name\" : \"nginx\" , \"EndpointID\" : \"c3b64e072f7851e3bf55ba3685fa1fbdec6b9c59 d18ae27e5e90a1be5728f54c\" , \"MacAddress\" : \"02:42:ac:11:00:02\" , \"IPv4Address\" : \"172.17.0.2/16\" , \"IPv6Address\" : \"\" } } , \"Options\" : { \"com.docker.network.bridge.default_bridge\" : \"true\" , \"com.docker.network.bridge.enable_icc\" : \"true\" , \"com.docker.network.bridge. enable_ip_masquerade\" : \"true\" , \"com.docker.network.bridge. host_binding_ipv4\" : \"0.0.0.0\" , \"com.docker.network.bridge.name\" : \"docker0\" , \"com.docker.network.driver.mtu\" : \"1500\" } , \"Labels\" : {} } ] We can see that the container has an IP address of 172.17.0.2 and uses the gateway address of the docker0 interface. Now we know that our nginx service is running on port 80 inside the container. Indeed we can contact our service on port 80 using the IP 172.17.0.2 , try the following command from your docker host: Command Output curl http://172.17.0.2:80 <!DOCTYPE html> <html> <head> <title>Welcome to nginx!</title> <style> body { width: 35em ; margin: 0 auto ; font-family: Tahoma, Verdana, Arial, sans-serif ; } </style> </head> <body> <h1>Welcome to nginx!</h1> <p>If you see this page, the nginx web server is successfully installed and working. Further configuration is required.</p> <p>For online documentation and support please refer to <a href = \"http://nginx.org/\" >nginx.org</a>.<br/> Commercial support is available at <a href = \"http://nginx.com/\" >nginx.com</a>.</p> <p><em>Thank you for using nginx.</em></p> </body> </html> All the containers attached to the default bridge network can talk to each other. What if we want to reach the service running in the container using the local network on the host? Try the following command: curl http://127.0.0.1:80 It won't work... you will get: curl: (7) Failed to connect to 127.0.0.1 port 80: Connection refused ... We need to publish the service port in the container to a port on our local network. This can be done using the --publish option (or -p ) of the docker container run command. The correct syntax is: --publish <host port>:<container port> So let's start another container with this option: docker container run -d --name nginx2 -p 80 :80 nginx Look at the different description of the two containers: Command Output docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8d5609a40033 nginx \"/docker-entrypoint.\u2026\" 35 seconds ago Up 33 seconds 0 .0.0.0:80->80/tcp, :::80->80/tcp nginx2 2f03f1f2cd10 nginx \"/docker-entrypoint.\u2026\" 2 hours ago Up 2 hours 80 /tcp nginx We can see here that the container port 80 is mapped on the host port 80 ( 0.0.0.0:80->80/tcp, :::80->80/tcp ). As before, the command docker container inspect provides further information: ... \"NetworkSettings\" : { \"Bridge\" : \"\" , \"SandboxID\" : \"c66c74726ef8185887d6057d9efd1a4870f0b4b77543213d3bb4fe80db2bd48b\" , \"HairpinMode\" : false, \"LinkLocalIPv6Address\" : \"\" , \"LinkLocalIPv6PrefixLen\" : 0 , \"Ports\" : { \"80/tcp\" : [ { \"HostIp\" : \"0.0.0.0\" , \"HostPort\" : \"80\" } , { \"HostIp\" : \"::\" , \"HostPort\" : \"80\" } ] } , ... Now we can verify that our service is reachable on port 80 of our local network running the following command from the host: curl http://127.0.0.1:80 Indeed you can reach your service also from outside using the IP of your host. If the inbound connectivity on port 80 is ensured by the firewall rules, you can connect to the nginx service using the browser on your local workstation. Using a user-defined bridge network \u00b6 In the previous example we have seen that any container you run will be automatically attached to the default bridge network. Tip A user-defined bridge network has some important extra features w.r.t. the default one as described in the official docs on this topic: Automatic DNS resolution between containers Better isolation Containers can be attached and detached from user-defined networks on the fly Each user-defined network creates a configurable bridge Now use the docker network create command to create a user-defined bridge network: docker network create mynet You will get the ID of the newly created network, e.g.: 64319187a52ba82fcbff86b348b42c3ac847e5cfb6a2365b123b7de597ff6eee List the docker networks: you will see also mynet in the list: Command Output docker network ls 1 2 3 4 5 NETWORK ID NAME DRIVER SCOPE 0aa786b7de5f bridge bridge local 19747c3d0c9a host host local 64319187a52b mynet bridge local 36dc4ef5b900 none null local We can use the network connect command to attach a container to a network. Tip The syntax for this command is: docker network connect <network identifier> <container identifier> Let's connect our first nginx container: docker network connect mynet nginx Note that the container was already attached to the default bridge network. Let's inspect the container to get the new networking configuration: Command Output docker inspect nginx 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ... \"Networks\" : { \"bridge\" : { \"IPAMConfig\" : null, \"Links\" : null, \"Aliases\" : null, \"NetworkID\" : \"0aa786b7de5fbfcd3e18db78511ed544d450bb0ad198cab0244bc8b83d30b514\" , \"EndpointID\" : \"c3b64e072f7851e3bf55ba3685fa1fbdec6b9c59d18ae27e5e90a1be5728f54c\" , \"Gateway\" : \"172.17.0.1\" , \"IPAddress\" : \"172.17.0.2\" , \"IPPrefixLen\" : 16 , \"IPv6Gateway\" : \"\" , \"GlobalIPv6Address\" : \"\" , \"GlobalIPv6PrefixLen\" : 0 , \"MacAddress\" : \"02:42:ac:11:00:02\" , \"DriverOpts\" : null } , \"mynet\" : { \"IPAMConfig\" : {} , \"Links\" : null, \"Aliases\" : [ \"2f03f1f2cd10\" ] , \"NetworkID\" : \"64319187a52ba82fcbff86b348b42c3ac847e5cfb6a2365b123b7de597ff6eee\" , \"EndpointID\" : \"a232b9e5a82960e12762b949bc83b3e3bd5357580f937b69cae7097384e9eb69\" , \"Gateway\" : \"172.18.0.1\" , \"IPAddress\" : \"172.18.0.2\" , \"IPPrefixLen\" : 16 , \"IPv6Gateway\" : \"\" , \"GlobalIPv6Address\" : \"\" , \"GlobalIPv6PrefixLen\" : 0 , \"MacAddress\" : \"02:42:ac:12:00:02\" , \"DriverOpts\" : {} } } ... As you can see, our container has now two interfaces with IPs 172.17.0.2 (on the default network) and 172.18.0.2 (on mynet network). Note that we can also specify the network when we create the container using the --network option. Let's run the following command: docker run -it --net mynet ubuntu bash In this way you have created a container that is connected to mynet network. All containers attached to a user-defined network can communicate using their names (automatic DNS resolution)..so you can contact the container nginx directly (you don't need to know its IP). Inside the container, run the commands: apt update apt install -y curl then run the command curl http://nginx inside the ubuntu container to verify that the automatic DNS resolution is working: root@2f03f1f2cd10:/# curl http://nginx <!DOCTYPE html> <html> <head> <title>Welcome to nginx!</title> <style> body { width: 35em ; margin: 0 auto ; font-family: Tahoma, Verdana, Arial, sans-serif ; } </style> </head> <body> <h1>Welcome to nginx!</h1> <p>If you see this page, the nginx web server is successfully installed and working. Further configuration is required.</p> <p>For online documentation and support please refer to <a href = \"http://nginx.org/\" >nginx.org</a>.<br/> Commercial support is available at <a href = \"http://nginx.com/\" >nginx.com</a>.</p> <p><em>Thank you for using nginx.</em></p> </body> </html> Tip In order for the automatic DNS resolution to work you must assign custom names to the containers. Using the randomly generated name will not work. Lab challenge \u00b6 Goal : create a service based on two containers: WordPress MySQL and then use your web browser to access wordpress on port 8080. Tip Create a volume db_data to provide persistent storage for the DBMS Create a network Launch MySQL (image name: mysql or mariadb ) with container name db , using the previously created volume, attaching it to the previously created network and pass environment variables to the container to configure it Launch WordPress (image name: wordpress:latest ) with container name wordpress , and pass environment variables to the container to configure it Use the automatic DNS resolution feature of the previously created network to connect the two containers","title":"Bridge mode and port mapping"},{"location":"networking/networking/#using-a-user-defined-bridge-network","text":"In the previous example we have seen that any container you run will be automatically attached to the default bridge network. Tip A user-defined bridge network has some important extra features w.r.t. the default one as described in the official docs on this topic: Automatic DNS resolution between containers Better isolation Containers can be attached and detached from user-defined networks on the fly Each user-defined network creates a configurable bridge Now use the docker network create command to create a user-defined bridge network: docker network create mynet You will get the ID of the newly created network, e.g.: 64319187a52ba82fcbff86b348b42c3ac847e5cfb6a2365b123b7de597ff6eee List the docker networks: you will see also mynet in the list: Command Output docker network ls 1 2 3 4 5 NETWORK ID NAME DRIVER SCOPE 0aa786b7de5f bridge bridge local 19747c3d0c9a host host local 64319187a52b mynet bridge local 36dc4ef5b900 none null local We can use the network connect command to attach a container to a network. Tip The syntax for this command is: docker network connect <network identifier> <container identifier> Let's connect our first nginx container: docker network connect mynet nginx Note that the container was already attached to the default bridge network. Let's inspect the container to get the new networking configuration: Command Output docker inspect nginx 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ... \"Networks\" : { \"bridge\" : { \"IPAMConfig\" : null, \"Links\" : null, \"Aliases\" : null, \"NetworkID\" : \"0aa786b7de5fbfcd3e18db78511ed544d450bb0ad198cab0244bc8b83d30b514\" , \"EndpointID\" : \"c3b64e072f7851e3bf55ba3685fa1fbdec6b9c59d18ae27e5e90a1be5728f54c\" , \"Gateway\" : \"172.17.0.1\" , \"IPAddress\" : \"172.17.0.2\" , \"IPPrefixLen\" : 16 , \"IPv6Gateway\" : \"\" , \"GlobalIPv6Address\" : \"\" , \"GlobalIPv6PrefixLen\" : 0 , \"MacAddress\" : \"02:42:ac:11:00:02\" , \"DriverOpts\" : null } , \"mynet\" : { \"IPAMConfig\" : {} , \"Links\" : null, \"Aliases\" : [ \"2f03f1f2cd10\" ] , \"NetworkID\" : \"64319187a52ba82fcbff86b348b42c3ac847e5cfb6a2365b123b7de597ff6eee\" , \"EndpointID\" : \"a232b9e5a82960e12762b949bc83b3e3bd5357580f937b69cae7097384e9eb69\" , \"Gateway\" : \"172.18.0.1\" , \"IPAddress\" : \"172.18.0.2\" , \"IPPrefixLen\" : 16 , \"IPv6Gateway\" : \"\" , \"GlobalIPv6Address\" : \"\" , \"GlobalIPv6PrefixLen\" : 0 , \"MacAddress\" : \"02:42:ac:12:00:02\" , \"DriverOpts\" : {} } } ... As you can see, our container has now two interfaces with IPs 172.17.0.2 (on the default network) and 172.18.0.2 (on mynet network). Note that we can also specify the network when we create the container using the --network option. Let's run the following command: docker run -it --net mynet ubuntu bash In this way you have created a container that is connected to mynet network. All containers attached to a user-defined network can communicate using their names (automatic DNS resolution)..so you can contact the container nginx directly (you don't need to know its IP). Inside the container, run the commands: apt update apt install -y curl then run the command curl http://nginx inside the ubuntu container to verify that the automatic DNS resolution is working: root@2f03f1f2cd10:/# curl http://nginx <!DOCTYPE html> <html> <head> <title>Welcome to nginx!</title> <style> body { width: 35em ; margin: 0 auto ; font-family: Tahoma, Verdana, Arial, sans-serif ; } </style> </head> <body> <h1>Welcome to nginx!</h1> <p>If you see this page, the nginx web server is successfully installed and working. Further configuration is required.</p> <p>For online documentation and support please refer to <a href = \"http://nginx.org/\" >nginx.org</a>.<br/> Commercial support is available at <a href = \"http://nginx.com/\" >nginx.com</a>.</p> <p><em>Thank you for using nginx.</em></p> </body> </html> Tip In order for the automatic DNS resolution to work you must assign custom names to the containers. Using the randomly generated name will not work.","title":"Using a user-defined bridge network"},{"location":"networking/networking/#lab-challenge","text":"Goal : create a service based on two containers: WordPress MySQL and then use your web browser to access wordpress on port 8080. Tip Create a volume db_data to provide persistent storage for the DBMS Create a network Launch MySQL (image name: mysql or mariadb ) with container name db , using the previously created volume, attaching it to the previously created network and pass environment variables to the container to configure it Launch WordPress (image name: wordpress:latest ) with container name wordpress , and pass environment variables to the container to configure it Use the automatic DNS resolution feature of the previously created network to connect the two containers","title":"Lab challenge"}]}